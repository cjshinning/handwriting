<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>23、HTTP和HTTPS</title>
</head>
<body>
    <h3>HTTP和HTTPS</h3>
    <h4>三次握手：</h4>
    <p>
        <img src="./img/1.image" alt="">
    </p>
    <p></p>
    <h4>四次挥手</h4>
    <p>
        <img src="./img/2.image" alt="">
    </p>
    <h4>HTTPS工作原理：</h4>
    <p>
        <img src="./img/3.image" alt="">
    </p>
    <script>
        // 一、UDP连接
        // 用户数据包协议（User Datagram Protocol），简称UDP，是基于IP之上开发能和应用打交道的协议
        // 缺陷：
        // 数据包在传输过程中容易丢失
        // 大文件传输中，UDP并不知道如何组成这些数据包，不知道如何还原成完整的文件
        // 虽然UDP不能保证数据可靠性，但是传输速度非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等

        // 二、TCP连接
        // TCP（Transmission Control Protocol，传输控制协议）是一种面向连接、可靠的、基于字节流的传输层通信协议
        // 特点：
        // 对于数据包的丢失，建立重传机制
        // TCP引入数据包排序机制，用来保证把乱码的数据包组合成一个完整的文件

        // 3个过程：
        // 1、建立连接阶段
        // 通过3次握手来建立客户端和服务端之间的连接
        // 三次握手，是指建立一个TCP连接时，客户端和服务端总共要发送3个数据包来确认连接的建立

        // 作用：
        // 确认双方的接收能力和发送能力
        // 指定自己的初始化序列号，为后面的可靠性做准备

        // 三次握手过程：
        // 刚开始客户端处于closed的状态，服务端处于Listen状态。
        // tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)
        // （1）客户端发送到服务端。客户端发送SYN报文给服务端，并且指明客户端序列号为ISN(c)，即1以SYN=1,seq=x的形式发送过。此时客户端处于SYN_SEND状态。
        // （2）服务端发送给客户端。服务端收到客户端的SYN和ISN(c)，也发送一个SYN回去，同时设置ACK=ISN(c)+1以及指明服务器初始化序列号为ISN(s)，即以SYN=1,ACK=x+1,seq=y的形式发送给客户端。此时服务端处于SYN_RECEIVED状态
        // （3）客户端发送到服务器。客户端收到服务器发送的信息后，设置ACK=ISN(s)+1，将自身的ISN(c)+1，即以ACK=y+1,seq=x+1的形式发送给服务器。此时客户端处于ESTABLISHED阶段，双方建立了连接。

        // 三次握手目的：
        // 1、客户端发送数据给服务端，服务器确认自己可以接受客户端的请求。
        // 2、服务端发送数据给客户端，客户端确认自己可以发送数据给服务端，也可以接受到服务端的请求。
        // 3、客户端发送数据给服务器，服务器确认自己可以发送数据给客户端。

        // 两次握手的问题：
        // 1、客户端发送一次请求后给服务器，指定时间后没响应再发了一个
        // 2、服务端先接收到后一个建立连接的请求，然后前一个建立连接的请求，因为网络延迟等问题，在第二个之后达到了
        // 3、服务器认为第二个请求是最新发的，于是客户端发送确认报文段同意建立连接，于是连接建立了（两次握手）
        // 4、这时候客户端还在等待最新的请求连接（第二次请假），自动忽略服务器发送的关于第一个请求连接的响应，也不发送数据
        // 5、服务器一直等待客户端发送数据，服务器资源被占用。

        // 三次握手可以携带数据吗？
        // 第三次可以，第一二次不可以。
        // 如果第一次可以携带数据的话，有可能是恶意攻击服务器。这时候释放大量的数据，不理会服务器的承受能力，让服务器花费很多时间，内存空间接受豹纹。
        // 第三次握手的时候，客户端处于ESTABLISHED状态了，它可以建立连接并且知道服务器的接收、发送能力是正常的，所以可以携带数据了。

        // 2、传输数据阶段
        // 此时客户端和服务器都处于ESTABLISHED状态。

        // 3、断开连接阶段
        // 数据传输完毕后，需要终止连接，通过四次挥手来保证双方都能断开连接。
        
        // 四次挥手过程：
        // 1、客户端发送给服务器。客户端以FIN=1,seq=u的形式发送给服务器，表示要客户端和服务器的数据传输。此时客户端处于FIN_WAIT状态。
        // 2、服务端发送给客户端。服务器收到欣欣，先返回ACK给客户端，即以ACK=1,seq=v,ack=u+1的形式返回给客户端，表示收到客户端报文了。此时服务器处于CLOSE_WAIT状态。
        // 3、服务器发送给客户端。服务器等待一会，看客户端还没有数据过了，等处理完这些数据之后，也想断开了，于是发送FIN给客户端，即以FIN=1,ACK=1,seq=w,ack=u+1的形式发送给客户端。此时服务器处于LAST_ACK状态。
        // 4、客户端发送给服务器。客户端收到FIN之后，返回ACK报文做为应答，即以ACK=1,seq=w+1的形式发送给服务端。此时客户端处于TIME_WAIT状态。

        // 过一阵子后，客户端确保服务器收到自己的ACK报文了，则变成CLOSED状态。服务器端收到ACK报文后，就也处于CLOSED状态了。

        // 四、TCP和UDP的区别
        // TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接。
        // TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，无重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。并且因为TCP可靠，面向连接，不会丢失数据因此适合大量数据的交换。
        // TCP是面向字节流，UDP面向报文
        // TCP只能1对1，UDP支持1对1，1对多。
        // TCP的收不较大为20字节，而UDP只有8字节。
        // TCP是面向连接的可靠性传输，而UDP是不可靠的。

        // 五、HTTP发展史
        // 1、HTTP/0.9
        // 传输体积很小的文件，没有HTTP请求头和请求体，服务器也不返回头信息
        // 2、HTTP/1.0
        // 支持多类型的文件下载，加入了请求头和响应头支持多种不同类型的数据。
        // 3、HTTP/1.1
        // 长连接（keep-alive），新增了六种请求方法
        // 4、HTTP/2.0
        // 头部压缩、多路复用、服务器推送
        // 5、HTTP/3.0
        // 实现类似TCP的流量控制，传输可靠性的功能。
        // 集成了TLS加密功能。
        // 实现了HTTP/2中的多路复用功能。
        // 实现了快速握手功能。

        // 六、HTTP
        // 超文本传输协议
        // 1、请求方法：GET,HEAD,POST,PUT,DELETE,CONNECT,OPTIONS,TRACE
        // 2、优缺点：
        // 优点：
        // （1）灵活可扩展
        // （2）可靠传输
        // （3）请求-应答
        // （4）无状态

        // 3、GET和POST的区别
        // GET获取资源；POST提交/上传数据。
        // GET请求常德在浏览器中有限制，而POST并没有。
        // GET请求会被浏览器主动保留下了，而POST不会

        // 4、HTTP状态码
        // 1XX：表示目前是协议处理的中间状态，还需要后续操作。
        // 2XX：表示成功状态。
        // 200 OK, 206 partical Content
        // 3XX：重定向状态，资源位置发生变动，需要重新请求。
        // 301 Move Permanently：永久重定向
        // 302 Found：临时重定向。
        // 304 Not Modified：命中协商缓存。
        // 4XX：请求报文有误。
        // 400 Bad Request：请求无效。
        // 403 Forbidden：服务器已经得到请求，但是拒绝执行，比如没有权限
        // 404 Not Found：资源未找到，服务器不存在对应资源
        // 5XX：服务器端发送错误。
        // 500 Internal Server Error：服务器报错
        // 502 Bad Gateway：访问出错
        // 503 service Unavailabel：服务器繁忙或者停机维护，暂时无法处理请求。

        // HTTPS工作原理
        // 1、浏览器请求 URL，找到服务器，向服务器发送请求。服务器将自己的证书（包含服务器公钥）、对称加密算法种类以及其他相关信息返回给浏览器。
        // 2、浏览器检查 CA 证书是否可依赖，确认证书有效。
        // 3、如果不是，给服务器发警告，询问是否可以继续使用。
        // 4、如果是，浏览器使用公钥加密一个随机对称秘钥，包含加密的 URL 一起发送给服务器。
        // 5、服务器用自己的私钥解密浏览器发送的钥匙，然后用这把对称加密的钥匙给浏览器请求的 URL 连接解密。
        // 6、服务器用浏览器发送的对称钥匙给请求的网页加密，浏览器使用相同的钥匙就可以解密网页。

        // HTTP和HTTPS对比
        // 概念对比。HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议
        // 费用对比。HTTPS协议需要CA证书，费用较高。
        // 连接方式和端口。使用不同的连接方式，端口也不同，一般而言，HTTP端口为80,HTTPS为443
        // 安全性对比。HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。

        // HTTP2：
        // 由于HTTPS在安全性方面以及做的很好了，HTTP2重点在于性能提升：
        // 头部压缩：HTTP2压缩头部消息投，减少了传输数据的大小
        // 多路复用：即多个请求都通过一个TCP连接并发完成

    </script>
</body>
</html>