<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>html总结</title>
</head>
<body>
    <!-- <pre>
        在html5之后不再需要指定DTD文档，因为html5以前的html文档都是基于SGML的，所以需要通过DTD来定义文档中允许的属性以及一些规则。
        而html5不在基于SGML了，所以不需要再使用DTD

        2、标准模式和兼容模式有什么区别？
        标准模式的渲染方式和JS引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法无法工作。
    </pre> -->
    <script>
        // 参考：https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/Html/Html.md
        // 1、DOCTYPE的作用是什么？
        // <!DOCTYPE>声明一般位于文档的第一行，它的作用是告诉浏览器以什么样的模式来解析文档。
        // 在html5之后不再需要指定DTD文档，因为html5以前的html文档都是基于SGML的，所以需要通过DTD来定义文档中允许的属性以及一些规则。而html5不在基于SGML了，所以不需要再使用DTD

        // 2、标准模式和兼容模式有什么区别？
        // 标准模式的渲染方式和JS引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法无法工作。

        // 3、HTML5为什么只需要写<!DOCTYPE html>，而不需要引入DTD？
        // HTML5不给予SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器行为
        // HTML4是基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。

        // 4、SGML,HTML,XML,XHML的区别？
        // SGML是标准通用标记语言，是一种定义电子文档解构和面熟其内容的国际标准语言，是所有电子文档标记语言的起源。
        // HTML是超文本标记语言，主要是用于规定怎么显示网页。
        // XML是可扩展标记语言，是未来网页语言的发展方向
        // XHTML也是现在基本上网页都在用的标记语言，和HTML没有本质的区别，标签都一样，用法也一样，但是比HTML更严格。

        // 5、DTD介绍？
        // DTD是一组及其可读规则，他们定义XML或HTML的特定版本中所有允许元素以及他们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性且采取相应措施。
        // DTD还会影响浏览器的渲染模式
        
        // 6、行内元素的定义？
        // 一个元素只占据它对应的标签的边框所包含的空间。
        // 常见有：a b  span img strong sub sup button input label select textarea

        // 7、块级元素的定义？
        // 块级元素占据父元素的整个宽度
        // 常见：div ul ol li dl dt dd h1-h6 p

        // 8、行内元素和块级元素的区别？
        // html4中，元素被分成两大类：inline（内联元素）和block（块级元素）
        // （1）格式上，默认情况下，行内元素不会以新行开始，而块级元素会与新起一行
        // （2）内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素
        // （3）行内元素与块级元素属性的不同，主要时盒模型属性上：行内元素设置width无效，height无效（可以设置line-height），设置margin和padding的上下不会对其他元素产生影响。

        // 9、HTML5元素分类？
        // （1）结构性元素  section header footer nav article
        // （2）块级性元素  aside figure code dialog
        // （3）行内语义元素 meter time progress video audio
        // （4）交互行元素  details datagrid menu command

        // 10、空元素的定义
        // 标签内没有内容的HTML标签被称为空元素。空元素是在开始标签中关闭的。
        // 常见：br hr img input link meta

        // 11、link标签定义
        // link标签定义文档与外部资源的关系。
        // link元素是空元素，它包含属性。此元素只能存在于head部分，不过它可以出现任何次数
        // link表情中的rel属性定义了当前文档与被链接文档直接的关系。常见的stylesheet指定一个外部加载的样式表。

        // 12、页面倒入样式时，使用link和@import有什么区别？
        // （1）从属关系区别。@import是css提供的语法规则，只要导入样式表的作用；link是HTML提供的标签，不仅可以加载css，还可以定义rss,rel链接属性、引入网站图标等。
        // （2）加载顺序区别。加载页面时，link标签引入的css被同时加载；@import引入的css将在页面加载完毕后被加载
        // （3）兼容性区别。@import是css2才有的语法，只可在ie5+才能识别；link标签作为HTML元素，不存在兼容性问题
        // （4）DOM可控性区别。可以通过JS操作DOM，插入link标签来改变样式；由于DOM是基于文档的，无法使用@import的方式插入样式

        // 13、你对浏览器的理解？
        // 浏览器的功能主要是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是html，也包括PDF、image以及其他格式。用户用URI来指定所请求的资源位置。
        // HTML和CSS规范中规定了浏览器解释html文档的方式，由W3C组织对这些规范进行维护，W3C是负责制定web标准的组织。
        // 但是浏览器厂商纷纷开发自己的扩展，对规范遵循并不完善，这为web开发者带来了严重的兼容性问题。
        // 简单来说浏览器可以分为两部分，shell和内核
        // 其中shell种类相对比较多，内核则比较少。shell是指浏览器的外壳：例如菜单、工具栏等。主要是给用户界面操作，参数设置等。它是调用内核来实现各种功能。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。

        // 14、介绍一下你对浏览器内核的理解？
        // 主要分为两部分：渲染引擎和JS引擎
        // 渲染引擎的指责就是渲染，即在浏览器窗口中显示所请求的内容。
        // JS引擎：解析和执行javascript来实现网页的动态效果。

        // 15、常见浏览器内核比较
        // Trident：这种浏览器内核是IE浏览器的内核，因为早期IE占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核写的，但是实际上这个内核对真正的网页标准支持不是很好。
        // Gecko：这是Firefox和Flock所采用的内核，这个内核的优点是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是显而易见就是要消耗很多资源，比如内存
        // Presto：Opera曾经采用的内核，被公认为网页速度最快的内核
        // Webkit：Webkit是Safari采用的内核，它的优点是网页浏览速度较快，虽然不及Presto但也胜于Gecko和Trident，缺点网页兼容性不高
        // Blink：谷歌浏览器的内核，是Webkit的一个分支

        // 16、常用浏览器内核
        // （1）IE：Trident
        // （2）Chrome：以前是Webkit，现在是Blink
        // （3）Firefox：Gecko
        // （4）Safari：Webkit

        // 17、浏览器渲染原理？
        // （1）解析HTML生成DOM树
        // （2）解析CSS生成CSS规则树
        // （3）根据DOM树和CSS规则树生成render树
        // （4）根据渲染树进行Layout布局（回流）。这一阶段浏览器要做的是钱是要弄清楚各个节点在页面中的确切位置和大小。
        // （5）布局结束后进入绘制阶段，遍历渲染树并调用对象的paint方法将他们的内容显示在屏幕上，绘制使用UI基础基础。

        // 18、渲染过程遇到JS文件怎么处理？
        // Javascript的加载、解析与执行会阻塞文档的解析，也就是说在构建DOM树时，HTML若是遇到了Javascript，它会暂停文档的解析，将控制权交给Javascript引擎，等Javascript引擎运行完毕，浏览器再从中断的地方解析文档。
        // 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载JS文件，这也是都建议将script标签在body标签底部的愿意。当然，并不是说script标签必须放在底部，因为你可以给script添加defer或者async

        // 19、async和defer的作用是什么？有什么区别？
        // （1）脚本没有defer或async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。
        // （2）defer属性表示延迟执行引入的Javascript，即这段Javascript加载时HTML并未停止解析，这两个过程时并行的。当整个document解析完毕后再执行脚本文件，在DOMContentLoaded事件出发之前完成。多个脚本顺序执行
        // （3）async表示一步执行引入的Javascript，与defer的区别在于，如果已经加载好，就会立即执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。

        // 20、什么是文档的预解析？
        // Webkit和Firefox都做了这个优化，当执行Javascript脚本时，另一个线程解析剩下的文档，并加载后面需要通过忘了加载的资源。这张方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变DOMs树，它将这个工作留给主解析过程，自己直接洗外部资源的引用，比如外部脚本、样式表以及图片

        // 21、css如何阻塞文档解析？
        // 理论上，既然样式表不改变DOM树，也就没有必要停下来等待他们，然而，存在一个问题，Javascript脚本执行时可能在文档解析过程请求样式，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。
        // 所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。

        // 22、渲染页面时常见哪些不良现象？
        // FOUC：主要是指样式山所的问题，由于浏览器渲染机制，在css加载之前，先呈现了HTML，就会展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是css加载时间过程，或者css被放在了文档底部。
        // 白屏：有些浏览器渲染机制（比如chrome）要先构建DOM树和CSSOM树，构建完成后再进行渲染，如果CSS部分放在HTML尾部，由于CSS未加载完成，浏览器迟迟未渲染，从而导致白屏。也可能是js文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。

        // 23、如何优化关键渲染路径？
        // （1）对关键路径进行分析和特性描述：资源数、字节数、长度。
        // （2）最大限度减少关键资源数量
        // （3）优化关键字节数以缩短下载时间
        // （4）优化其余关键资源加载顺序

        // 24、什么是重绘和回流？
        // 重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如background-color，我们将这样的操作称为重绘。
        // 回流：当渲染树中的一部分因为元素规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响布局的操作，这样的操作我们称为回流。
        // 任何改变几何信息的操作，都会触发回流
        // （1）添加或删除可见的DOM元素
        // （2）元素尺寸改变-边距、填充、边框、宽高
        // （3）内容变化，比如用户在input框中输入文字
        // （4）浏览器窗口尺寸改变-resize事件发生时
        // （5）计算offsetWidth和offsetHeight属性
        // （6）设置style属性的值
        // （7）当你修改网页的默认字体时
        // 回流必定发生重绘，重绘不一定引发回流

        // 25、如何减少回流？
        // （1）使用transform代替top
        // （2）不要把节点的属性值放在一个循环当成循环的变量
        // （3）不要使用table布局，可能很小的改动会造成整个table的重新布局
        // （4）把DOM离线后修改。如：使用documentFragment对象在内存里操作DOM
        // （5）不要一条一条的修改DOM样式。比如修改class

        // 26、为什么操作DOM慢？
        // 一些DOM的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗

        // 27、DOMContentLoaded事件和Load事件的区别？
        // HTML文档完全加载和解析完成之后，DOMContentLoaded事件被触发，无需等待样式表、图像和子框架加载完成。
        // Loaded事件是当所有资源加载完成后触发。

        // 28、HTML5有哪些新特性？移除了哪些元素？
        // HTML5现在已经不是SGML的仔鸡，主要是关于图像，位置，存储，多任务等功能的增加。
        // 新增的有：
        // 绘画canvas
        // 用于媒体回放的video和audio元素
        // 本地离线存储
        // 更好的语义化标签，如article,footer,header,nav,section
        // 表单控件，如calendar,date,time,email,url,search
        // 新的技术 webworker,websocket

        // 移除的有：
        // 纯表现的元素：basefont,big,center,font,s,strike,tt,u
        // 对可用性产生负面影响的元素：frame,frameset,noframes

        // 29、如何处理HTML5新标签的浏览器兼容问题？
        // （1） IE8/IE7/IE6支持通过document.createElement方法产生标签，然后加上标签默认的样式
        // （2）可以直接使用成熟的框架，比如html5shiv
        
        // 30、简述一些你对HTML语义化的理解？
        // （1）用正确的标签做正确的事情
        // （2）html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析
        // （3）即使没有样式情况下也以一种文档格式显示，并且是容易阅读的
        // （4）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键词的权重
        // （5）使阅读源代码的人更容易将网站分块，便于阅读维护理解

        // 31、b与strong区别和i与em的区别？
        // 从页面显示效果来说，被<b>和<strong>包围的文字都将会被加粗，而被<i>和<em>包围的文字将以斜体的形式呈现。
        // 但是<b><i>是自然样式标签，分别表示无意义的加粗，无意义的斜体
        // 而<em><strong>是语义样式标签。<em>一般表示强调文本，而<strong>比<em>语义更强调的文本

        // 32、前端需要注意哪些seo？
        // （1）合理的title,description,keywords
        // （2）语义化的HTML代码，符合W3C规范；语义化代码让搜索引擎容易理解
        // （3）重要内容HTML代码放在最前面
        // （4）重要内容不要用js输出
        // （5）少用iframe，搜索引擎不会抓取iframe中的内容
        // （6）非装饰性的图片必须加alt
        // （7）提高网站速度；网站速度是搜索引擎排序的一个重要指标

        // 33、HTML5的离线存储怎么使用，解释一下工作原理
        // 用户没有与因特网链接时，可以正常访问站点或英语，在用户与因特网连接时，更新用户机器上的缓存文件
        // 原理：HTML5的离线存储时基于一个新建的.appcache文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后网络处理离线状态下，浏览器会通过被离线存储的数据进行页面展示

        // 34、浏览器时怎么对HTML5的离线存储资源进行管理和加载的呢？
        // 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。

        // 35、常见的浏览器的存储技术有哪些？
        // cookie,localStorage,sessionStorage

        // 36、请描述一些cookie,localStorage,sessionStorage的区别？
        // cookie其实最开始时服务端用于记录用户状态的一种方式，由服务端设置，在客户端存储，然后每次发起同源请求时，发送给服务端。coookie最多存储4k数据，它的生存时间由expires属性指定，并且cookie只被同源的页面访问
        // sessionStorage是html5提供的一种本地存储的方法，它借鉴了服务端session的概念，代表一次会话中所保存的数据。它一般能够存储5m或者更大的数据，它在当前窗口关闭后就失效了，并且sessionStorage只能被同一个窗口的同源页面所访问。
        // localStorage是html5提供的一种本地存储的方法，它一般能够存储5m或者更大的数据。它和sessionStorage不同的是，除非手动删除它，否则它不会失效，并且ocalStorage也只能被同源页面所访问。

        // 37、iframe有哪些缺点？
        // （1）iframe会阻塞主页面的onload事件。
        // （2）搜索引擎无法解读这张页面，不利于seo。
        // （3）iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
        // （4）浏览器后退按钮失效
        // （5）小型的移动设备无法完全显示框架

        // 38、Label的作用是什么？是怎么用的？
        // label标签是用来定义表单控制间的关系，当用户选择该标签事，浏览器会自动将焦点转到和标签相关的表单控件上。
        // <label for="Name">Number:</label>
        // <input type=“text“ name="Name" id="Name"/>

        // 39. HTML5 的 form 的自动完成功能是什么？

        // 40、如何实现浏览器多个标签页之间的通信？
        // WebSocket,localStorage,postMessage

        // 41、WebSocket如何兼容低版本浏览器？
        // Adobe Flash Socket 、
        // ActiveX HTMLFile (IE) 、
        // 基于 multipart 编码发送 XHR 、
        // 基于长轮询的 XHR

        // 42、页面可见性可以有哪些用途？
        // （1）对服务器的轮询
        // （2）网页动画
        // （3）正在播放的音频或视频

        // 43、如何在页面上实现一个圆形的可点击区域？
        // （1）纯html实现，使用 <area> 来给 <img> 图像标记热点区域的方式
        // （2）纯css实现，使用border-radius
        // （3）纯js实现

        // 44、实现不实用boder画出1px高度的线，在不同浏览器的标准模式和怪异模式下保持一致的效果
        // <div style="height:1px;overflow:hidden;background: red"></div>

        // 45、title和h1的区别？
        // title没有明确意义只是表示是个标题，h1则表示层次明确的标题，对网页信息的抓取业余很大的影响。

        // 46、<img>的title和alt有什么区别？
        // title通常当鼠标滑动到元素上时显示
        // alt是<img>的特有属性，是图片内容的等价描述，用于图片无法加载时显示，读屏阅读图片。可提高图片访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。

        // 47、Canvas和SVG有什么区别？
        // Canvas是一种通过Javascript来绘制2D图片的方法，是逐像素进行渲染的，当我们对canvas进行缩放，会出现锯齿或者失真的情况。
        // SVG是一种使用XML描述2D图片的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。

        // 48、网页验证码是干嘛的，是为了解决什么安全问题？
        // （1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷屏、论坛灌水
        // （2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试

        // 49、渐进增强和优雅降级的定义？
        // 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验
        // 优雅降级：一开始就根据高版本浏览器构建完整功能，然后再针对低版本浏览器进行兼容

        // 50、attribute和property的区别是什么？
        // attribute是dom元素在文档中作为html标签拥有的属性；
        // property就是dom元素在js中作为对象拥有的属性
        // 对于html标准属性来说，attribute和property是同步的，是会自动更新的
        // 但是对于自定义属性来说，他们是不同步的

        // 51、对web标准、可用性、可访问性的理解
        // 可用性：产品是否容易上手，用户能否完成任务，效率如何，以及这个过程中用户的主管感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力。
        // 可访问性：web内容对于残章用户的可阅读和可理解性
        // 可维护性：一般包括两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。

        // 52、 IE 各版本和 Chrome 可以并行下载多少个资源？
        // （1）  IE6 2 个并发
        // （2）  iE7 升级之后的 6 个并发，之后版本也是 6 个
        // （3）  Firefox，chrome 也是6个

        // 53、Flash,Ajax鸽子的优缺点，在使用中如何取舍？
        // Flash：
        // （1）适合处理多媒体、矢量图形、访问机器
        // （2）对css、处理文本上不足，不容易被搜索
        // Ajax：
        // （1）对css、文本支持很好，支持搜索
        // （2）多媒体、矢量图形、访问机器访问不走
        // 共同点：
        // （1）与服务器的无刷新传递消息
        // （2）可检测用户离线和在线状态
        // （3）操作DOM

        // 54、怎么重构页面？
        // （1）编写css
        // （2）让页面结构更合理化，提升用户体验
        // （3）实现良好的页面效果和提升性能

        // 55、浏览器架构
        // 用户界面
            // 主进程
            // 内核
                // 渲染引擎
                // JS引擎
                    // 执行栈
                // 事件触发线程
                    // 消息队列
                        // 微任务
                        // 宏任务
                // 网络异步线程
                // 定时器线程

        // 56、常用的meta
        // <meta name="description" content="不超过150个字符">
        // <meta name="keywords" content="">
        // <meta name="author" content="jenny">
        // <meta name="robots" content="index,follow">
        // <meta name="apple-mobile-web-app-title" content="标题">
        // <meta name="apple-mobile-web-app-capable" content="yes">
        // <meta name="app-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL">
        // <meta name="apple-mobile-web-app-status-bar-style" content="black">
        // <meta name="format-detection" content="telphone=no,email=no">
        // <meta name="screen-orientation" content="portraint">
        // <meta name="x5-orientation" content="portraint">
        // <meta name="browermode" content="application">
        // <meta name="x5-page-mode" content="app">
        // <meta name="viewpoint" content="width=device-width, initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no">

        // 57、css reset和normalize.css有什么区别？
        // css reset时最早的一种解决浏览器之间样式不兼容的方案，它的基本思想是将浏览器所有的样式都重置掉，从而达到所有浏览器样式保持一直的效果。但是这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式重置，其实反而会造成画蛇添足的效果。
        // 后面出现一种更好的解决浏览器间样式兼容的方法，就是normalize.css，它的思想是尽量保留浏览器的自带样式，通过在原有样式的基础上进行调整，来保持各浏览器间的样式保持一致。相对于css reset，normalize.css保留了有价值的默认值，并且修复了一些浏览器bug，而且使用normalize.css不会造成元素复杂的继承链。

        // 58、用于预格式化文本的标签是？
        // 预格式化就是保留文字在源码中的格式，最后显示出来样式与源码中保持一致，所见即所得。
        // <pre>定义预格式文本，保持文本原油的格式

        // 59、DHTML是什么？
        // DHTML将html,javascript,dom以及css组合在一起，用于创建动态性更强的网页，能够动态的改变html元素的样式

        // 60、head标签中必不可少的是？
        // <title>，是head部分中唯一必须的元素

        // 61、HTML5新增的表单元素有？
        // datalist 规定输入域的选项列表，通过option创建
        // keygen 提供一种严重用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书
        // output元素用于不同类型的输出

        // 62、在HTML5中，哪个方法用于获取用户的当前位置？
        // getCurrentPosition()

        // 63、文档的不同注释方式？
        // HTML  的注释方法 <!-- 注释内容 -->
        // CSS 的注释方法 /* 注释内容 */
        // Javascript 的注释方法 /* 多行注释 */ //单行注释

        // 64、disabled和readonly的区别？
        // disabled 指当input元素加载时禁止此元素。input内容不会随着表单提交
        // readonly 规定输入的字段为只能。input内容会随着表单提交
        // 无论设置哪个，通过js脚本都可以更改input的value

        // 65、主流浏览器内核私有属性css前缀？
        // mozilla内核 -moz
        // webkit内核 -webkit
        // opera内核 -o
        // trident内核 -ms

        // 66、前端性能优化？
        // 加载优化：：：
        // （1）减少http请求
        // 合并css和js，使用css雪碧图
        // （2）缓存资源
        // （3）压缩代码
        // 压缩代码，启用gzip
        // （4）无阻塞
        // 样式放在头部并使用link方式引入，脚本放在尾部并使用一步方式加载
        // （5）首屏加载
        // （6）按需加载
        // 懒加载、滚屏加载
        // （7）预加载
        // （8）压缩图像
        // （9）避免重定向
        // （10）异步加载第三方资源
        // 执行优化：：：
        // （1）css写在头部，js写在底部并且异步
        // （2）避免img,iframe等src为空
        // （3）尽量避免重置图像大小
        // （4）图像尽量避免使用DataURL
        // 渲染优化：：：
        // （1）设置viewport
        // （2）减少dom操作
        // （3）优化动画
        // （4）优化高频事件
        // （5）GPU加速
        // 样式优化：：：
        // （1）避免在html中写style
        // （2）避免css表达式
        // （3）避免过长的选择器
        // 脚本优化：：：
        // （1）减少重绘和回流
        // （2）缓存DOM选择和计算
        // （3）使用事件代理

        // 67. Chrome 中的 Waterfall ？

        // 68. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？

        // 69. Html 规范中为什么要求引用资源不加协议头http或者https？
    </script>
</body>
</html>