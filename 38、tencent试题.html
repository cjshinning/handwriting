<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>tencent试题</title>
    <style>
        .test {
            width: 3rem;
            height: 4rem;
            background: #000;
        }

        #priority {
            color: rgb(0, 0, 255) !important;
        }

        #allHeight {
            width: 300px;
            height: 200px;
            background: #ccc;
            padding: 50px;
            border: 10px solid #000;
            overflow: auto;
        }
    </style>
    <script>
        // 简易版-手机自适应
        // (function(doc, win){
        //     var docEl = document.documentElement,
        //         resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
        //         recalc = function(){
        //             var clientWidth = docEl.clientWidth;
        //             if(!clientWidth) return;

        //             console.log(clientWidth);

        //             // docEl.style.fontSize = 100 * (clientWidth/750) + 'px';
        //             docEl.style.fontSize = (clientWidth/10) + 'px';
        //         }
        //     if(!doc.addEventListener) return;
        //     recalc();
        //     window.addEventListener(resizeEvt, recalc, false);
        // })(document, window);
    </script>
</head>

<body>
    <section>
        <h2>HTML,CSS,浏览器 相关</h2>

        <h3>1、网络中使用最多的图片格式有哪些</h3>
        <p>JPEG, GIF, PNG，最流行的是JPEG格式，可以把文件压缩到最小，在ps以JPEG格式存储时，提供11级压缩级别</p>

        <h3>2、请简述css盒子模型</h3>
        <p>
            <img width="500" src="./img/ie-box.png" alt="">
        </p>
        <p>css盒模型从外岛内可以分为4个部分：margin（外边距）、border（边框）、padding（内边距）、content（内容）。默认情况下，盒子的width和height熟悉只是content的宽和高。</p>
        <p>参考：<a href="https://segmentfault.com/a/1190000015235886"
                target="_blank">https://segmentfault.com/a/1190000015235886</a></p>

        <h3>3、视频/音频标签的使用</h3>
        <p>视频使用：
            <!-- <video src=""></video> -->
        </p>
        <p>标签属性：</p>
        <p>src 需要播放的视频地址；</p>
        <p>width/height 设置播放视频的宽高；</p>
        <p>autoplay 是否自动播放；</p>
        <p>controls 是否显示控制条；</p>
        <p>poster 没有播放之前现实的展示图片；</p>
        <p>loop 是否循环播放；</p>
        <p>preload 预加载视频；与autoplay冲突，设置了autoplay属性，preload属性会失效；</p>
        <p>muted 静音模式；</p>
        <p>使用：<audio src=""></audio></p>
        <p>音频：属性和视频差不多，不过狂傲和poster属性不能用</p>

        <h3>4、HTML5新增的内容有哪些？</h3>
        <p>新增语义化标签、表单类型、表单元素、表单事件、多媒体标签、canvas和svg、本地存储等</p>

        <h3>5、HTML5新增的语义化标签有哪些？</h3>
        <p>语义化优点：（1）提升可访问性（2）seo（3）结构清晰，利于维护</p>
        <p>header 页面头部；main 页面主要内容；footer 页面底部；nav 导航栏；aside 侧边栏；aticle 页面的一块独立内容；section 区块相当于div；figure
            价值独立内容（上图下字）；Hgroup 标题组合标签；mark 高亮显示；dialog 加载对话框标签；Embed 加载插件的标签；video 视频； audio 音频；</p>

        <h3>6、css3新增的特性？</h3>
        <p>边框：border-radius；背景：background-size；渐变：linear-gradient()；文本：word-wrap和text-overflow；转换：transform；2d转换：rotate,translate,scale等；3d转换：perspective；过渡：transition；动画：animation；
        </p>

        <h3>7、清楚浮动的方式有哪些？说出各自的优点</h3>
        <p>浮动会导致高度坍塌，当所有的子元素浮动的时候，如果父元素没有设置高度，这时候就会导致父元素高度坍塌；</p>
        <p>（1）给父元素单独定义高度；</p>
        <p>优点：简单快速，代码少；缺点：无法进行响应式布局。</p>
        <p>（2）父级定义overflow:hidden;zoom:1;</p>
        <p>优点：简单快捷，代码少，兼容性好；缺点：超出部分将被隐藏，布局的时候要注意。</p>
        <p>（3）在浮动元素后面加一个空标签，{clear:both;height:0;overflow:hidden;}</p>
        <p>优点：简单快速，代码少，兼容性好；缺点：增加空标签，不利于页面优化。</p>
        <p>（4）父级定义overflow:auto;</p>
        <p>优点：简单，代码少，兼容性好；缺点：内容宽高超过父级div时，会出现滚动条。</p>
        <p>（5）万能清除法：给坍塌元素添加伪元素</p>
        <p>.father :after{ display:block;clear:both;content: '';height:0;overflow:hidden;visibility:hidden; }</p>
        <p>优点：写法固定，兼容性好；缺点：代码多。</p>
        <p>参考：<a href="https://segmentfault.com/a/1190000004865198"
                target="_blank">https://segmentfault.com/a/1190000004865198</a></p>

        <h3>8、定位的属性值有何区别？</h3>
        <p>position有四个属性值：relative, abosulte, fixed, static</p>
        <p>relative相对定位：不脱离文档流，相对于自身定位</p>
        <p>abosulte绝对定位：脱离文档流，相对于父级定位</p>
        <p>fixed固定定位：脱离文档流，相对于浏览器窗口定位</p>
        <p>static默认值，元素出现在正常的流中</p>

        <h3>9、子元素如何在父元素中居中？</h3>
        <p>略。。。</p>

        <h3>10、border-box和content-box的区别？</h3>
        <p>content-box 标准盒模型，width不包括padding和border；</p>
        <p>border-box 怪异（IE）盒模型，width包括padding和border；</p>

        <h3>11、元素垂直居中？</h3>
        <p>略。。。</p>

        <h3>12、如何让chrome浏览器显示小于12px的字体？</h3>
        <p>添加谷歌私有属性：-webkit-text-size-adjust: none; 或者设置-webkit-transform: scale()</p>

        <h3>13、css选择器有哪些？哪些属性可以继承？优先级如何计算？</h3>
        <p>元素选择器，id选择器，群组选择器，类选择器，通配符选择器，后代选择器，伪类选择器，伪元素选择器，属性选择器</p>

        <h3>14、网页中有大量图片加载很慢，你有什么办法进行优化？</h3>
        <p>图片懒加载，图片预加载，使用雪碧图</p>

        <h3>15、行内元素/块级元素有哪些？</h3>
        <p>行内元素：相邻的行内元素会排列在同一行，不会独占一行，设置宽高无效</p>
        <p>块级元素：会独占一行，可以设置宽高等属性</p>
        <p>块级元素：div h1-h6 hr p ul ol table address blockquote等</p>
        <p>行内元素：a br i em img input select span sub sup u textarea</p>

        <h3>16、浏览器的标准模式和怪异模式区别？</h3>
        <p>（1）盒模型的处理差异：标准盒模型的宽度和高度等于内容区的宽度和高度，不包含内边距和边框，而怪异模式下使用的是IE盒模型，宽高包含那边句和边框。</p>
        <p>（2）行内元素的垂直对齐：标准模式基于基线对齐，quirks模式下基于底部对齐。</p>
        <p>参考：<a href="https://www.jianshu.com/p/dcab7cde8c04"
                target="_blank">https://www.jianshu.com/p/dcab7cde8c04</a></p>

        <h3>17、margin和padding在什么场合下使用？</h3>
        <p>margin 外边距 自身边框到另一个边框之间的距离；</p>
        <p>padding 内边距 自身边距到自身内容之间的距离；</p>
        <p>当需要在border外侧添加空白时使用margin，当需要在border内侧添加空白时用padding。</p>

        <h3>18、弹性盒子布局属性有哪些？</h3>
        <p>flex-direction：弹性容器中子元素排列方式（主轴的方式）</p>
        <p>flex-wrap：设置弹性盒子的子元素超出父容器时是否换行</p>
        <p>flex-flow：是flex-direction和flex-wrap的简写形式</p>
        <p>justify-content：设置弹性盒子在主轴上的对齐方式</p>
        <p>align-items：设置弹性盒子在交叉轴上的对齐方式</p>
        <p>align-content：设置行对齐</p>
        <p>参考：<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html"
                target="_blank">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>

        <h3>19、怎么实现标签禁用？</h3>
        <p>添加disabled属性</p>

        <h3>20、flex布局原理？</h3>
        <p>通过给父盒子添加flex属性，来控制盒子的位置和排练方式</p>

        <h3>21、px，rem，em的区别？</h3>
        <p>px：绝对长度单位，相对于显示器屏幕分辨率而言的；</p>
        <p>em：相对长度单位，相对于父元素的字体大小；</p>
        <p>rem：相对于html跟元素的字体大小；</p>
        <p>参考：<a href="https://www.jianshu.com/p/a0bdd3e9133d"
                target="_blank">https://www.jianshu.com/p/a0bdd3e9133d</a></p>
        <!-- <div class="test">rem box</div> -->

        <h3>22、网页的三层结构有哪些？</h3>
        <p>结构（html）、表现（css）、行为（js）</p>

        <h4>23、说说媒体查询？</h4>
        <p>media属性，就是根据不同的媒体类型设置不同的css样式，达到自适应的目的。</p>

        <h3>24、rem缺点？</h3>
        <p>比如，小说网站，屏幕越小的移动设备，如果用了rem肯定文字就越小，会导致看文章的时候特别费眼。</p>

        <h3>25、css常见的兼容性？</h3>
        <p>浏览器对标签的默认支持不同，所以需要统一，进行css reset。</p>
        <p>IE6双边距bug：（1）给float元素添加display:inline;（2）用hack处理；</p>
        <p>上下margin重合问题，不要同时采用top和bottom</p>
        <p>min-height兼容性</p>
        <p>超链接访问回购样式混乱，hover不出现了。按照顺序：L-V-H-A</p>
        <p>chrome下默认会将小于12px的文本强制按照12px来解析。解决方案添加样式{-webkit-text-size-ajust: none}</p>
        <p>css控制透明度，一般之间用{opacity: 0.6}；IE就filter: alpha(opacity=60)</p>
        <p>css3风格前缀</p>
        <p>参考：<a href="https://blog.csdn.net/m0_38099607/article/details/72860686"
                target="_blank">https://blog.csdn.net/m0_38099607/article/details/72860686</a></p>

        <h3>26、垂直与水平居中方式？</h3>
        <p>略。。。</p>

        <h3>27、三栏布局两边固定中间自适应</h3>
        <p>（1）margin负值法：左右两栏均左浮动，左右两栏采用负的margin值，中间栏被宽度为100%的浮动元素包起来；</p>
        <p>（2）自身浮动法：左栏左浮动，右栏右浮动，中间栏放最后</p>
        <p>（3）绝对定位法：左右两栏采用绝对定位，分别固定于页面的左右两侧，中间的主体栏用左右margin值撑开距离；</p>
        <p>（4）flex布局；</p>
        <p>（5）grid布局；</p>
        <p>（6）table布局；</p>

        <h3>28、Doctype作用？</h3>
        <p>声明文档类型</p>

        <h3>29、说一下html5 drag api</h3>
        <p>略。。。</p>

        <h3>30、对HTML语义化的理解</h3>
        <p>指用正确的标签包含正确的内容，结构良好，便于阅读。</p>

        <h3>31、web性能优化</h3>
        <p>降低请求量：合并js，减少http请求数，gzip压缩，webp，lazyload；</p>
        <p>加快请求速度：预解析DNS，减少域名数，并行加载，CDN分发；</p>
        <p>缓存：http协议缓存轻轻，离线缓存mainifest，离线数据存储localStorage；</p>
        <p>渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。</p>

        <h3>32、浏览器缓存机制</h3>
        <p>缓存分两种：强缓存和协商缓存，根据响应的header内容来决定；</p>
        <p>强缓存相关字段有：expires，cache-control；如果同时存在，cache-control的优先级要高于expires；</p>
        <p>协商缓存相关字段有：Last-Modified/If Modified-Since和Etag/If-None-Match</p>

        <h3>33、浏览器输入网址到页面渲染全过程</h3>
        <p>DNS域名解析、TCP链接、发起HTTP请求、服务器处理请求并返回HTTP报文、解析渲染页面、连接结束</p>

        <h3>34、画一条0.5px的线</h3>
        <p>（1）采用meta viewpoint，设置initial-scale=0.5</p>
        <p>（2）采用border-image方式</p>
        <p>（3）采用transform: scale()</p>
        <p>参考：<a href="https://juejin.cn/post/6844903582370643975"
                target="_blank">https://juejin.cn/post/6844903582370643975</a></p>

        <section style="display:none;">
            <style>
                .hr {
                    width: 300px;
                    background: #000;
                }

                /* 方案一：直接设置0.5px */
                .hr.half-px {
                    height: 0.5px;
                }

                .hr.one-px {
                    height: 1px;
                }

                /* 结论：chrome下无用 */
            </style>
            <h4>0.5px</h4>
            <div class="hr half-px"></div>
            <h4>1px</h4>
            <div class="hr one-px"></div>
        </section>

        <section style="display:none;">
            <style>
                .hr {
                    width: 300px;
                    background: #000;
                }

                /* 方案二：使用缩放scaleY() */
                .hr.half-px {
                    height: 1px;
                    transform: scaleY(0.5);
                    transform-origin: 50% 100%;
                }

                .hr.one-px {
                    height: 1px;
                }

                /* 结论：chrome下有用 */
            </style>
            <h4>1px + scale(0.5)</h4>
            <div class="hr half-px"></div>
            <h4>1px</h4>
            <div class="hr one-px"></div>
        </section>

        <section style="display:none;">
            <style>
                .hr {
                    width: 300px;
                    background: #000;
                }

                /* 方案三：使用线性渐变 */
                .hr.half-px {
                    height: 1px;
                    background: linear-gradient(0deg, #fff, #000);
                }

                .hr.one-px {
                    height: 1px;
                }

                /* 结论：chrome下线是虚的 */
            </style>
            <h4>linear-gradient(0deg, #fff, #000)</h4>
            <div class="hr half-px"></div>
            <h4>1px</h4>
            <div class="hr one-px"></div>
        </section>

        <section style="display:none;">
            <style>
                .hr {
                    width: 300px;
                    background: #000;
                }

                /* 方案四：使用box-shadow */
                .hr.half-px {
                    height: 1px;
                    background: none;
                    box-shadow: 0 0.5px 0 #000;
                }

                .hr.one-px {
                    height: 1px;
                }

                /* 结论：chrome下线是虚的 */
            </style>
            <h4>box-shadow: 0 0.5px 0 #000;</h4>
            <div class="hr half-px"></div>
            <h4>1px</h4>
            <div class="hr one-px"></div>
        </section>

        <h3>35、关于js动画和css3动画的差异性</h3>
        <p>js动画缺点：在主线程中运行，而主线程还有其他需要运行的脚本、样式计算、布局、绘制等任务，对其干扰可能导致阻塞，从而造成丢帧的情况；另外复杂度高于css动画；</p>
        <p>js动画优点：动画控制能力很强，可以在动画播放过程中进行控制；比css3动画丰富；无兼容问题；</p>
        <p>css3动画缺点：运行过程中控制较弱，无法附加事件绑定回调函数；代码冗长；</p>
        <p>css3动画优点：代码相对简单，性能调优方向固定；对于支持不好的浏览器，可以做到自然降级；</p>

        <h3>36、双边距重叠问题</h3>
        <p>多个相邻（兄弟或者父子关系）普通流中的快元素垂直方向margin会重叠的结果为：</p>
        <p>两个相邻的外边距都是正数时，折叠的结构时他们两者之间较大的值。两个相邻外边距都是负数时，折叠结果是两者绝对值的较大值。两个外边距一正一负时，折叠结果时两者相加的和。</p>

        <h3>37、清除浮动</h3>
        <p>参考题7</p>

        <h3>38、css选择器有哪些？优先级？</h3>
        <p>id选择器，class选择器，标签选择器，伪类选择器，伪元素选择器</p>
        <p>优先级为：id选择器 > class选择器 > 标签选择器</p>
        <p id="priority" style="color:green;">带有!important标记的样式属性优先级最高</p>
        <p>样式来源不同时，优先级为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式</p>
        <p><b style="color:red">!important > style内联样式</b></p>

        <h3>39、css动画如何实现？</h3>
        <p>animation：由keyframe规则实现</p>
        <p>transition：过渡动画</p>

        <h3>40、如何实现元素的垂直居中？</h3>
        <p>方案一：父元素display:flex;align-items:center;</p>
        <p>方案二：元素绝对定位，top:50%;margin-top:-(高度/2)</p>
        <p>方案三：高度不固定，元素绝对定位，top:50%;transform: translate(-50%)</p>
        <p>父元素table布局，子元素设置verticle-align:center;</p>

        <h3>41、css3中对溢出的处理</h3>
        <p>text-overflow属性，clip时修剪文本；ellipsis为现实省略符号；string为使用给定的字符串来代表被修剪的文本</p>

        <h3>42、对css3的新属性有了解过吗？</h3>
        <p>css3的新特性中，在布局方面新增了flex布局，在选择器方面新增了first-of-type，nth-child等选择器，在盒模型方面添加了box-sizing来改变盒模型，在动画方面增加了animation，2d变换，3d变换等，在颜色方面添加透明度，rgba等，在字体方面允许嵌入字体和设置阴影等，最后还有媒体查询。
        </p>

        <h3>43、overflow的原理</h3>
        <p>块级格式上下文</p>

        <h3>44、css定位</h3>
        <p>static：默认值，设置top，left，bottom，right无效；</p>
        <p>relative：相对于自身定位，必须搭配top，left，bottom，right使用，用来指定偏移的方向和距离。</p>
        <p>absolute：相对于不为static的父级定位，没有就相对于跟元素html定位，必须搭配top，left，bottom，right使用。</p>
        <p>fixed：相对于视口（浏览器窗口）进行偏移，元素不会随着页面滚动而变化，须搭配top，left，bottom，right使用。</p>
        <p>sticky：它会产生动态效果，很像relative和fixed的结合：一些时候是relative定位，另一些时候自动变成fixed定位。</p>
        <p>参考：<a href="https://www.ruanyifeng.com/blog/2019/11/css-position.html"
                target="_blank">https://www.ruanyifeng.com/blog/2019/11/css-position.html</a></p>
    </section>

    <section>
        <h2>Javascript相关</h2>

        <h3>1、js基础数据类型？</h3>
        <p>字符串string，数值number，布尔boolean，null，undefined，Symbol</p>

        <h3>2、Ajax如何使用？</h3>
        <p>一个完整的Ajax请求包括五个步骤：</p>
        <p>（1）创建XMLHttpRequest对象</p>
        <p>（2）使用open方法创建http请求，并设置请求地址</p>
        <p>（3）设置发送的数据，用send发送请求</p>
        <p>（4）注册事件，获取响应并更新页面</p>

        <h3>3、如何判断一个数据是NaN？</h3>
        <p>NaN 非数字，用typeof检测是number类型；</p>
        <p>（1）利用NaN是唯一一个不等于自身的特点；</p>
        <p>（2）利用ES6中提供的Object.is()方法；</p>
        <p>（3）使用isNaN（不推荐）</p>

        <h3>5、闭包是什么？有什么特性？对页面会有什么影响？</h3>
        <p>闭包就是有权访问其他函数内部变量的函数。</p>
        <p>简单理解成：定义在一个函数内部的函数。其中一个内部函数在包含他们的外部函数之外被调用时，就形成了闭包。</p>
        <p>特点：</p>
        <p>（1）函数嵌套函数</p>
        <p>（2）函数内部可以引用外部的参数和变量</p>
        <p>（3）参数和变量不会被垃圾回收机制回收</p>
        <p>使用：</p>
        <p>（1）读取函数内部的变量</p>
        <p>（2）这些变量始终保存在内存中，不会在外层函数调用后自动清除</p>
        <p>优点：</p>
        <p>（1）变量长期驻扎在内存中；</p>
        <p>（2）避免全局变量的污染；</p>
        <p>（3）私有成员的存在；</p>
        <p>缺点：会造成内存泄漏</p>
        <p>参考：<a
                href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a>
        </p>

        <h3>6、js中常见的内存泄漏</h3>
        <p>（1）意外的全局变量；</p>
        <p>（2）被遗忘的计时器或回调函数；</p>
        <p>（3）脱离DOM的引用；</p>
        <p>（4）闭包</p>

        <h3>7、事件委托是什么？如何确定事件源？</h3>
        <p>事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。</p>
        <p>事件委托，又称事件代理，是js中很常见的绑定事件的技巧，事件委托就是把原来需要绑定在自元素的响应事件委托给父元素，让父元素担当事件监听的职务，事件委托的原理是DOM元素的事件冒泡。</p>

        <h3>8、什么是事件冒泡？</h3>
        <p>一个事件触发后，会在自元素和父元素之间传播，这种传播分为三个阶段：</p>
        <p>捕获阶段：从window对象传到目标节点（从外到里），这个阶段不会响应任何事件；</p>
        <p>目标阶段：在目标节点上触发</p>
        <p>冒泡阶段：从目标节点传回window对象（从里到外），事件委托就是利用事件冒泡的机制把里层需要响应的事件绑定到外层</p>

        <h3>9、本地存储和cookie的区别？</h3>
        <p>cookie非常小，它的大小限制是4kb，主要用途有保存登录信息；</p>
        <p>localStorage是HTML5标准中加入的技术，它并不是什么划时代的新东西。</p>
        <p>sessionStorage与localStorage接口类似，但是保存数据的生命周期不同。sessionStorage是可以将一部分数据在当前会话中保存下来，刷新页面数据依然存在，但当页面关闭后，sessionStorage中的数据就会被清空。
        </p>
        <p>三者异同：</p>
        <p>（1）数据的生命周期：</p>
        <p>cookie一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效；</p>
        <p>localStorage除非手动清除，否则永远保存；</p>
        <p>sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除；</p>
        <p>（2）存放数据大小：</p>
        <p>cookie是4kb左右；</p>
        <p>localStorage，sessionStorage一般为5m；</p>
        <p>（3）与服务器通信：</p>
        <p>cookie每次都会携带在http头中，如果使用cookie保存过多数据带来性能问题；</p>
        <p>localStorage，sessionStorage仅在客户端（浏览器）中保存，不参与和服务器通信；</p>
        <p>（4）易用性：</p>
        <p>cookie需要自己封装</p>
        <p>localStorage，sessionStorage有现成api接口可以使用；</p>
        <p>参考：<a
                href="https://cloud.tencent.com/developer/article/1408696">https://cloud.tencent.com/developer/article/1408696</a>
        </p>

        <h3>10、ES6新特性</h3>
        <p>const和let、模板字符串、箭头函数、函数的参数默认值、对象和数组解构、for...of和for...in，ES6中的类。</p>

        <h3>11、let和var以及const区别？</h3>
        <p>var声明的变量会挂载在window上，而let和const生命的变量不会；</p>
        <p>var声明的变量存在变量提升，let和const不存在变量提升；</p>
        <p>同一作用域下var可以声明同名变量,let和const不可以；</p>
        <p>let和const声明会形成块级作用域；</p>
        <p>let暂存死区；</p>
        <p>const一旦声明必须赋值，不能用null占位，声明后不能再修改，如果声明的是复合类型数据，可以修改属性；</p>
        <p>参考：<a href="https://www.jianshu.com/p/4e9cd99ecbf5"
                target="_blank">https://www.jianshu.com/p/4e9cd99ecbf5</a></p>

        <h3>12、数组方法有哪些？请简述</h3>
        <!-- <p>自答：push从后面插入，unshift从前面插入，pop从后面删除，shift从前面删除，concat连接，reverse反转，includes是否包含，splice，forEach遍历，map</p> -->
        <p>（1）push()从后面添加元素，返回值为添加完后的数组长度；</p>
        <p>（2）pop()从后端删除元素，返回值是删除的元素；</p>
        <p>（3）shift()从前面删除元素，只能删一个，返回值是删除的元素；</p>
        <p>（4）unshift()从前面添加元素，返回值是添加完后的数组长度；</p>
        <p>（5）splice(i, n)删除从i（索引值）开始之后的那个元素，返回值是删除的元素；</p>
        <p>（6）concat()连接两个数组，返回值为连接后的新数组；</p>
        <p>（7）sort()将数组进行排序，返回值是排好的数组，默认按照最左边的数字排序，不是按照大小顺序拍的；</p>
        <p>（8）reverse()将数组反转，返回值是反转后的数组；</p>
        <p>（9）slice(start, end)截取索引值start到索引值end的数组，不包含end索引的值，返回值是截取的数组；</p>
        <p>（10）forEach(callback)遍历数组，无return，即使有return，也不会返回任何值，并且影响原来的数组；</p>
        <p>（11）map(callback)遍历数组，有return返回一个新数组；</p>
        <p>（12）filter(callback)过滤数组，返回一个满足要求的数组；</p>

        <h3>13、json如何新增和删除键值对？</h3>
        <p>新增：json[key]: value；删除：遍历对象</p>

        <h3>14、什么是面向对象？请简述</h3>
        <p>面向对象是一种编程思想，是基于面向过程而言的。它将真是世界各种复杂关系，抽象为一个个对象，然后由对象之间分工与合作，完成对真实世界的模拟。</p>
        <p>特点：封装（隐藏对象的属性和实现细节，对外提供公共访问方式）、继承（提高代码复用性）和多肽（父类或接口定义的引用变量可以指向子类或具体实现类的实例对象）</p>

        <h3>15、普通函数和构造函数的区别？</h3>
        <p>（1）构造函数也是一个普通函数，创建方式和普通函数一样，但是构造函数习惯上首字母大写；</p>
        <p>（2）调用方式不一样，普通函数直接调用，构造函数要用关键字new来调用；</p>
        <p>（3）调用时，构造函数会内部创建一个新对象，就是实例，普通函数不会创建新对象；</p>
        <p>（4）构造函数内部的this指向实例，普通函数内部的this指向调用函数的对象；</p>
        <p>（5）构造函数默认的返回值是创建的对象（也就是实例），普通函数的返回值由return语句决定；</p>
        <p>（6）构造函数的函数名与类名相同；</p>

        <h3>16、请简述原型、原型链、继承</h3>
        <h4>prototype 和 __proto__</h4>
        <p>（1）每个对象都有一个__proto__属性，并且指向它的prototype原型对象；</p>
        <p>（2）每个构造函数都有一个prototype原型对象；</p>
        <p>prototype原型对象里的constructor指向构造函数本身；</p>
        <p>
            <img src="./img/proto-1.png" alt="">
        </p>
        <p>实力对象的__proto__指向构造函数的prototype，从而实现继承；</p>
        <h4>原型链：</h4>
        <p>每一个对象都一个__proto__，它指向它的prototype原型对象，而prototype原型对象又有自己的prototype原型对象，这样层层往上直到一个对象的原型prototype为null，这个查询的路径就是原型链
        </p>
        <h4>继承</h4>
        <p>是指一个对象直接使用另一个对象的属性和方法</p>
        <p>参考：<a href="https://zhuanlan.zhihu.com/p/35790971">https://zhuanlan.zhihu.com/p/35790971</a></p>

        <h3>17、对Promise的理解</h3>
        <p>什么是Promise？</p>
        <p>Promise是一种解决异步编程的方案，相比回调函数和事件更合理和更强大。</p>
        <p>Promise有三种状态：pending初始状态也叫等待状态，fulfilled成功状态，rejected失败状态；状态一旦改变，就不会再变。创建Promise实例后，它会立即执行。</p>
        <p>Promise两个特点：</p>
        <p>（1）Promise对象的状态不受外界影响；</p>
        <p>（2）Promise的状态一旦改变，就不会再变，任何时候都可以得到这个结果，状态不可逆；</p>
        <p>Promise的三个缺点：</p>
        <p>（1）无法取消Promise，一旦新建它就会立即执行，无法中途取消；</p>
        <p>（2）如果不设置回调函数，Promise内部抛出错误，不会反映到外部；</p>
        <p>（3）当处于pending状态时，无法得知目标进展到哪一个阶段；</p>

        <h3>18、我们用Promise来解决什么问题？</h3>
        <p>回调地狱，代码难以维护，常常第一个函数的输出时第二个函数输入这种现象；</p>
        <p>Promise可以支持多并发的请求，获取并发请求中的数据；</p>
        <p>Promise可以解决异步的问题，本身不能说Promise是异步的。</p>

        <h3>19、请简述async的用法</h3>
        <p>async就是generation和Promise的语法糖，async就是将generator的*换成async，将yild换成await</p>
        <p>函数前必须加一个async，异步操作方法前加一个await关键字，意思就是等一下，执行完了再继续走，注意：await只能在async函数中运行，否则会报错；</p>
        <p>Promise如果返回的是一个错误的结果，如果没有做异常处理，就会报错，所以用try...catch捕获一下就可以了。</p>

        <h3>20、一个页面从输入url到页面加载显示完成，这个过程都发生了什么？</h3>
        <p>DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器解析渲染页面、连接结束</p>
        <p>参考：<a href="https://segmentfault.com/a/1190000006879700">https://segmentfault.com/a/1190000006879700</a></p>

        <h3>21、get请求传餐长度的误区？</h3>
        <p>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。实际上http协议从未规定过get/post的请求长度限制是多少。对get请求参数的限制是来源于浏览器或web服务器，它们限制了url的长度。
        </p>

        <h3>22、补充get和post请求在缓存方面的区别？</h3>
        <p>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</p>
        <p>post请求不同，一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存；</p>

        <h3>23、说一下闭包</h3>
        <p>一句话概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。</p>

        <h3>24、说说前端中的事件流</h3>
        <p>事件流描述的是从页面中接收事件的顺序；</p>
        <p>DOM2级事件流包含下面阶段：</p>
        <p>事件捕获阶段、处于目标阶段、事件冒泡阶段</p>

        <h3>25、说一下事件委托</h3>
        <p>简介：事件委托值得是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断时间发生元素的dom的类型，作出不同的响应。</p>
        <p>举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件的时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</p>
        <p>好处：比较合适动态元素的绑定，新添加的自元素也会有监听函数，也可以有事件触发机制。</p>

        <h3>26、js中的new操作符做了哪些事情？</h3>
        <p>new操作符创建了一个空对象，然后将这个对象的原型指向构造函数的prototype，执行构造函数后返回这个对象。</p>

        <h3>27、改变函数内部this指针的指向函数（bind，apply，call）的区别？</h3>
        <p>通过call和apply改变函数的this指向，他们两个函数的第一个参数都是一样，表示要改变指向的那个对象，第二个参数，apply是数组，而call是arg1,arg2...的类数组形式。通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。
        </p>

        <h3>28、js的各种位置，比如clientHeight，scrollHeight，offsetHeight，以及scrollTop，offsetTop，clientTop的区别？</h3>
        <p>clientHeight：表示可视区的高度，不包含border和滚动条</p>
        <p>offsetHeight：表示可视区的高度，包含border和滚动条</p>
        <p>scrollHeight：表示所有区域的高度，包含了因为滚动而被隐藏的部分。</p>
        <p>clientTop：表示边框border的厚度，在未指定的情况下一般为0</p>
        <p>scrollTop：滚动后被隐藏的高度</p>
        <p>offsetTop：返回当前元素相对与最近的offsetParent父节点顶部的距离。和滚动条没有关系。</p>
        <div id="allHeight"></div>

        <h3>29、拖拽功能的实现？</h3>
        <p>参考：https://juejin.cn/post/6844904158273765384</p>

        <h3>30、JS中的垃圾回收机制</h3>
        <p>JS会在创建变量时自动分配内存，在不使用的时候会自动周期性的释放内存，释放的过程就叫“垃圾回收”。</p>
        <p>回收算法：标记清除法和引用计数法</p>
        <p>内存泄漏：意外的全局变量，定时器，闭包，事件监听</p>
        <p>参考：<a href="https://segmentfault.com/a/1190000038175558">https://segmentfault.com/a/1190000038175558</a></p>

        <h3>31、JS监听对象属性的改变</h3>
        <p>（1）ES5的Object.defineProperty</p>
        <p>（2）ES6的Proxy</p>

        <h3>32、自己实现一个bind函数</h3>
        <p>参考：<a href="./9、bind模拟实现.html" target="_blank">9、bind模拟实现.html</a></p>

        <h3>33、怎么控制一次加载一张图片，加载完再加载下一张？</h3>
        <p>参考：<a href="https://www.cnblogs.com/lyt0207/p/13796529.html"
                target="_blank">https://www.cnblogs.com/lyt0207/p/13796529.html</a></p>

        <h3>34、JS实现深度克隆？</h3>
        <p>参考：<a href="./3、克隆.html" target="_blank">3、克隆.html</a></p>

        <h3>35、能讲讲JS语言特性吗？</h3>
        <p>一般运行在客户端浏览器上，nodejs兴起后也可以运行于服务端；</p>
        <p>不需要编译，直接解析执行代码；是弱类型语言，较为灵活；</p>
        <p>跨平台，脚本语言</p>

        <h3>35、JS全排列</h3>
        <p>参考：<a href="https://juejin.cn/post/6844903696132734989"
                target="_blank">https://juejin.cn/post/6844903696132734989</a></p>
    </section>

    <section>
        <h2>Jquery相关</h2>

        <h3>1、css预处理sass less是什么？为什么要使用他们？</h3>
        <p>sass和less都是css预处理器，是css上的一种抽象层，是一种特殊的语法，最终会编译成css，less是一种动态样式语言，给css赋予了动态语言特性，比如：变量，继承，嵌套。less既可以在客户端运行，也可以在服务端运行。
        </p>

        <h3>2、JS中call()和apply()的区别</h3>
        <p>call()和apply()都是调用对象的一个方法，用另一个对象代替当前对象。而不同之处在于传递的参数，apply最多只能两个参数——新this对象和一个数组，如果arg不是数组则会报错；</p>
        <p>相同点：两个方法作用一样，都是借助别人的方法来调用。</p>
        <p>不同点：方法传递的参数不同。</p>

        <h3>3、为什么会造成跨域？请简述同源策略？</h3>
        <p>在前后端分离的模式下，前后端的域名是不一致的，此时就会发送跨域访问问题。</p>
        <p>跨越问题来源于浏览器的同源策略，即只有协议+主机名+端口号相同，才允许相互访问。也就是说浏览器只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。</p>
        <p>同源策略是NetScape提出的一个著名的安全策略。所谓同源，指的是协议、域名、端口相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。</p>

        <h3>4、请输出三种减少页面加载时间的方式？</h3>
        <p>（1）优化图片</p>
        <p>（2）优化css</p>
        <p>（3）标明高度和宽度</p>
        <p>（4）减少http请求（合并资源）</p>

        <h3>5、this指向</h3>
        <p>在js中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象。</p>
        <p>全局的this->指向window</p>
        <p>对象中的this->指向其本身</p>
        <p>事件中的this->指向事件对象</p>

        <h3>6、jsonp的工作原理是什么？它为什么不是真正的ajax？</h3>
        <p>（1）js跨域请求数据是不可以的，但是js跨域请求js脚本是可以的。</p>
        <p>（2）所以可以把要请求的数据封装成一个js语句，做一个方法的调用。</p>
        <p>（3）跨域请求js脚本可以得到此脚本，得到js脚本后会立即执行。</p>
        <p>（4）可以把数据作为参数传递到方法中，就能获得数据，从而解决跨域问题。</p>
        <p>（5）jsonp的原理：（动态创建script标签，回调函数）</p>
        <p>浏览器在js请求中，是允许通过script标签的src跨域请求，可以在请求的结果中添加回调方法名，在请求页面中定义方法，就可以获取到跨域请求的数据。</p>

        <p>为什么不是真正的ajax？</p>
        <p>（1）ajax和jsonp这两种技术在调用方式上看起来很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装。</p>
        <p>（2）但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取页面内容，而jsonp是动态添加script标签来调用服务器提供的js脚本。</p>
        <p>（3）所以说，其实ajax和jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排期同域数据的获取。</p>
        <p>（4）jsonp是一种方式或者说非强制协议。</p>
        <p>参考：<a href="./22、jsonp实现.html" target="_blank">22、jsonp实现.html</a></p>

        <h3>7、请掌握两种以上的数组去重方式</h3>
        <p>（1）利用ES6 Set去重</p>
        <p>（2）利用for循环嵌套for循环，然后splice去重</p>
        <p>（3）利用indexOf去重</p>
        <p>（4）利用sort()</p>
        <p>（5）利用对象的属性不能相同的特点进行去重</p>
        <p>（6）利用includes</p>
        <p>（7）利用hasOwnProperty</p>
        <p>（8）利用filter</p>
        <p>（9）利用递归去重</p>
        <p>（10）利用Map数据结果去重</p>
        <p>（11）利用reduce+includes</p>
        <p>（12）[...new Set(arr)]</p>
        <p>参考：<a href="https://segmentfault.com/a/1190000016418021"
                target="_blank">https://segmentfault.com/a/1190000016418021</a></p>

        <h3>8、深浅拷贝如何实现？</h3>
        <p>参考：<a href="https://juejin.cn/post/6844903493925371917"
                target="_blank">https://juejin.cn/post/6844903493925371917</a></p>

        <h3>9、为什么js是弱类型语言？</h3>
        <p>弱类型语言是相对于强类型来说的，在强类型语言中，变量的类型有很多种，比如int char float
            boolean，不同类型相互转换有时候需要强制转换，而js只有一种类型var，为变量复制时会自动判断类型并且转换，所以是弱类型语言。</p>

        <h3>10、怎么转换less为css？</h3>
        <p>（1）用node将less文件生成css文件；</p>
        <p>（2）用webstorm自动生成；</p>

        <h3>11、echarts使用最多的是什么？</h3>
        <p>图标以及图标组合</p>

        <h3>12、for循环和map循环有什么区别？</h3>
        <p>for遍历对象自身和继承可枚举的属性，也就是说会包含那些原型链上的属性</p>
        <p>map方法不会对空数组进行检测，会返回一个新数组，不会对原数组产生影响。</p>

        <h3>13、请写出一个简单的类与继承；</h3>
        <p>使用语法结果创建对象、使用构造器创建对象、Object.create创建对象、class关键字创建对象</p>
        <p>继承：原型链继承、借用构造函数法、组合继承、原型式继承、寄生式继承、寄生组合继承</p>
        <p><a href="https://github.com/mqyqingfeng/Blog/issues/16"
                target="_blank">https://github.com/mqyqingfeng/Blog/issues/16</a></p>

        <h3>14、同步、异步的区别/阻塞、非阻塞的区别</h3>
        <p>同步（阻塞的），异步（非阻塞）</p>
        <p>比如：同步，咱俩在一起上班，到吃饭时间了，我去喊你吃饭，你很忙，我就坐着等你忙完再一起去吃饭；</p>
        <p>异步：咱俩在一起上班，到吃饭时间了，我去喊你吃饭，你很忙，我就先自己去吃了，你忙完了再去吃饭；</p>
        <p><a href="https://segmentfault.com/a/1190000013039660"
                target="_blank">https://segmentfault.com/a/1190000013039660</a></p>

        <h3>15、重绘和回流是什么？</h3>
        <p>重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如background-color，我们将这样的操作称为重绘。</p>
        <p>回流：当渲染树中的一部分因为元素规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响布局的操作，这样的操作我们称为回流。</p>
        <p>任何改变几何信息的操作，都会触发回流</p>
        <p>（1）添加或删除可见的DOM元素</p>
        <p>（2）元素尺寸改变-边距、填充、边框、宽高</p>
        <p>（3）内容变化，比如用户在input框中输入文字</p>
        <p>（4）浏览器窗口尺寸改变-resize事件发生时</p>
        <p>（5）计算offsetWidth和offsetHeight属性</p>
        <p>（6）设置style属性的值</p>
        <p>（7）当你修改网页的默认字体时</p>
        <p>回流必定发生重绘，重绘不一定引发回流</p>

        <h3>16、http是什么？有什么特点？</h3>
        <p>http叫做超文本传输协议，是互联网应用最广泛的一种网络协议；</p>
        <p>特点：基于请求-响应模式、无状态、无连连。</p>

        <h3>17、http和https区别？</h3>
        <p>http是超文本传输协议，信息是明文传输，https是具有安全行的ssl加密传输协议；</p>
        <p>http和https连接方式完全不同，端口也不同，http是80，https是443；</p>
        <p>http的连接很简单，是无状态的，https是由ssl+http协议构建的可进行加密传输，身份认证的网络协议，比http协议安全；</p>

        <h3>18、call和apply区别？</h3>
        <p>第一个参数相同，call从第二个参数起是参数列表，apply第二个参数是数组。</p>

        <h3>19、箭头函数和普通函数的区别？</h3>
        <p>（1）语法更加简介、清晰</p>
        <p>（2）箭头函数不会创建自己的this</p>
        <p>（3）箭头函数继承而来的this指向永远不变</p>
        <p>（4）call(),apply(),bind()无法改变箭头函数中的this的指向</p>
        <p>（5）箭头函数不能作为构造函数使用</p>
        <p>（6）箭头函数没有自己的arguments</p>
        <p>（7）箭头函数没有原型prototype</p>
        <p>（8）箭头函数不能用作Generator函数，不能使用yeid关键词</p>
        <p>参考：<a href="https://juejin.cn/post/6844903805960585224"
                target="_blank">https://juejin.cn/post/6844903805960585224</a></p>

        <h3>20、什么是js内存泄漏？</h3>
        <p>内存泄漏是指一块被分配的内存既不能使用又不能回收，直到浏览器进程结束；</p>
        <p>释放内存的方法：赋值为null。</p>

        <h3>21、你如何对网站的文件和资源进行优化？</h3>
        <p>（1）文件合并（目的减少http请求）；</p>
        <p>（2）文件压缩（目的是直接减少文件下载的体积）；</p>
        <p>（3）使用cdn托管资源；</p>
        <p>（4）使用缓存</p>
        <p>（5）开启gzip压缩</p>
        <p>（6）meta标签优化、heading标签优化、alt优化</p>
        <p>（7）反向连接，网站外链优化</p>
        <p>（8）按需加载资源</p>

        <h3>22、请简述ajax的执行过程，以及常见的http状态码；</h3>
        <h4>ajax的执行过程：</h4>
        <p>（1）创建一个XMLHttpRequest对象；</p>
        <p>（2）创建一个新的http请求，并指定请求方式、url、验证信息；</p>
        <p>（4）发送http请求；</p>
        <p>（5）设置响应http请求状态变化的函数，并获取异步调用返回的数据；</p>
        <p>（6）使用Javascript和dom实现局部刷新。</p>
        <h4>常见的http状态码：</h4>
        <p>1XX：表示目前是协议处理的中间状态，还需要后续操作。</p>
        <p>2XX：表示成功状态。</p>
        <p>200 OK, 206 partical Content</p>
        <p>3XX：重定向状态，资源位置发生变动，需要重新请求。</p>
        <p>301 Move Permanently：永久重定向</p>
        <p>302 Found：临时重定向。</p>
        <p>304 Not Modified：命中协商缓存。</p>
        <p>4XX：请求报文有误。</p>
        <p>400 Bad Request：请求无效。</p>
        <p>403 Forbidden：服务器已经得到请求，但是拒绝执行，比如没有权限</p>
        <p>404 Not Found：资源未找到，服务器不存在对应资源</p>
        <p>5XX：服务器端发送错误。</p>
        <p>500 Internal Server Error：服务器报错</p>
        <p>502 Bad Gateway：访问出错</p>
        <p>503 service Unavailabel：服务器繁忙或者停机维护，暂时无法处理请求。</p>

        <h3>预加载和懒加载的区别？预加载在什么时候加载合适？</h3>
        <p>（1）预加载是指页面在完成之前，提前将所需资源下载，之后使用的时候从缓存中调用；</p>
        <p>（2）懒加载是延迟加载，按照一定的条件或者需求等到满足条件的时候再加载对应资源；</p>
        <p>两者区别是一个提前加载，一个迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>

        <h3>24、jquery选择器有哪些？</h3>
        <p>基础选择器：ID选择器、类选择器、元素选择器、通配符选择器、</p>
        <p>层次选择器：后代选择器、子选择器、同辈选择器</p>
        <p>过滤选择器：基本过滤选择器、内容过滤器、可见性选择器、属性过滤器、表单对象属性过滤选择器</p>

        <h3>25、jquery插入节点的方法</h3>
        <p>append(),appendTo(),prepend(),prependTo(),after(),insertAfter(),before(),insertBefore()</p>

        <h3>26、js的函数节流和防抖的区别？</h3>
        <p>函数节流: 指定时间间隔内只会执行一次任务；</p>
        <p>函数防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</p>
        <p>参考：<a href="1、防抖和节流.html" target="_blank">1、防抖和节流.html</a></p>

        <h3>27、Get和Post不同之处</h3>
        <p>Get通常是从服务器获取数据，Post是向服务器传送数据；</p>
        <p>在客户端，get通过url提交数据，数据在url中可以看到，post方式，数据在html header中提交</p>
        <p>安全性问题</p>
        <p>Get提交数据最多只有1024字节，post没有限制</p>

        <h3>28、什么是csrf攻击？</h3>
        <p>通常情况下，CSRF攻击是攻击者借助受害者的Cookie骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p>
        <p>参考：<a href="40、XSS&CSRF.html" target="_blank">40、XSS&CSRF.html</a></p>

        <h3>29、什么时候用深拷贝/浅拷贝？</h3>
        <p>参考：<a href="3、克隆.html" target="_blank">3、克隆.html</a></p>
    </section>

    <section>
        <h2>Vue相关</h2>
        <h3>1、vue的核心是什么？</h3>
        <p>Vue是一套构建用户界面的渐进式自底向上增量开发的MVVM框架，vue的核心只关注视图层；</p>
        <p>核心思想：</p>
        <p>数据驱动（视图的内容随着数据的改变而改变）</p>
        <p>组件化（可以增加代码的复用性，可维护性，可测试性，提高开发效率，方便重复使用，体现了高内聚低耦合）</p>

        <h3>2、请简述你对vue的理解</h3>
        <p>Vue是一套构建用户界面的渐进式的自底向上增量开发的MVVM框架，核心是关注视图层；vue的核心是为了解决数据的绑定问题，为了开发大型单页面和组件化的应用，它的核心思想是数据驱动和组件化；</p>
        <p>这里也说一下MVVM思想，vm是v和m连接的桥梁，当模型数据修改时，vm层会检测到，并通知视图层进行响应修改。</p>

        <h3>3、请简述vue的单向数据流</h3>
        <p>父级prop的更新会向下流动到子组件中，每次父组件发生更新，子组件所有的prop都会刷新为最新的值；</p>
        <p>数据从父组件传递给子组件，只能单向绑定，子组件内部不能直接修改父组件传递过来的数据</p>

        <h3>4、Vue常用修饰符有哪些？</h3>
        <p>修饰符：</p>
        <p>.lazy 改变后触发，光标离开input输入框的时候值才会改变</p>
        <p>.number 将输出字符串转为number类型</p>
        <p>.trim 自动过滤用户输入的首尾空格</p>
        <p>事件修饰符：</p>
        <p>.stop 阻止点击冒泡，相当于原生js的event.stopPropagation()</p>
        <p>.prevent 防止执行预设的行为，相当于原生js中的event.preventDefault()</p>
        <p>.capture 添加事件侦听器时是呀事件捕获模式，就是谁有该事件修饰符，就先触发</p>
        <p>.self 只会触发自己范围的事件，不包括子元素</p>
        <p>.once 只执行一次</p>
        <p>键盘修饰符：</p>
        <p>.enter回车键 .tab制表键 .esc返回键 .space空格键 .up向上键 .down向下键 .left向左键 .right向右键</p>
        <p>系统修饰符：</p>
        <p>.ctrl .alt .shift .meta(mac下command键)</p>

        <h3>5、v-text与{{}}与v-html的区别？</h3>
        <p>{{}}将数据解析为纯文本，不能显示输出html</p>
        <p>v-html 可以渲染输出html</p>
        <p>v-text将数据解析为纯文本，不能输出真正的html，与花括号的区别是在页面加载时不限时双花括号</p>
        <p>v-text指令：</p>
        <p>作用：操作网页元素中的纯文本内容，{{}}是它的另外一种写法；</p>
        <p>v-text与{{}}区别：</p>
        <p>v-text与{{}}等价，{{}}叫模板插值，v-text叫指令</p>
        <p>有一点区别就是，在渲染的数据比较多的时候，可能会爸大阔好显示出来，俗称屏幕闪动；</p>

        <h3>6、v-on可以绑定多个方法吗？</h3>
        <p>可以，如果绑定多个事件，可以用键值对形式：事件类型: 事件名</p>
        <p>如果绑定是多个相同事件，直接用逗号分隔就行；</p>

        <h3>7、vue循环的key作用？</h3>
        <p>key值的存在保证了唯一性，vue在执行时，会对节点进行检查，如果没有key值，那么vue检查到这里有dom节点，就会对内容清空并且赋新值，如果有key值存在，那么会对新老节点进行对比，比较两者key是否相同，进行调换位置或删除操作。
        </p>

        <h3>8、什么时计算属性？</h3>
        <p>计算属性时用来声明式的描述一个值依赖了其他的值，当它依赖的这个值发生改变时，就更新DOM。</p>
        <p>当在模板中把数据绑定到一个计算属性上时，vue会在它依赖的任何值导致计算属性改变时更新DOM。</p>
        <p>每个计算属性都包括一个getter和setter，读取时触发getter，修改时触发setter。</p>

        <h3>9、vue单页面的优缺点？</h3>
        <p>优点：前后端分离，用户体验好，而且快，内容改变（切换路由）不需要重新加载整个页面；</p>
        <p>缺点：不利于seo，初次加载时耗长（浏览器一开始就要加载html css js，所有的页面内容都包含在主页面中），页面复杂度提高了，导航不可用。</p>

        <h3>10、vuex是什么？怎么使用？在哪种场景下使用？</h3>
        <p>vuex是也专门为vue应用程序开发的状态管理模式，通过创建一个集中的数据存储，方便程序中所有组件进行访问，简单来说vuex就是vue的状态管理工具。</p>

        <h3>11、vue中路由跳转方式</h3>
        <p>vue中路由跳转有两种，分别是声明式和编程式。</p>
        <p>用js方式进行跳转的叫编程式导航 this.$router.push()</p>
        <p>用router-link进行跳转的叫声明式路由，router-view路由出口，路由模板显示的位置</p>

        <h3>12、vue跨域的解决方式</h3>
        <p>（1）后台更改header</p>
        <p>（2）使用jquery提供jsonp</p>
        <p>（3）用http-proxy-middleware（配置代理服务器的中间件）</p>

        <h3>13、简述vue的生命周期</h3>
        <p>vue的生命周期就是vue实例创建到销毁的过程。期间会有8个钩子函数的调用。</p>
        <p>beforeCreate（实例初始化之前）</p>
        <p>created（实例创建完成）</p>
        <p>beforeMount（实例挂载开始之前）</p>
        <p>mounted（实例挂载之后）</p>
        <p>beforeUpdate（数据更新之前）</p>
        <p>updated（组件dom已经更新）</p>
        <p>beforeDestroy（实例销毁之前）</p>
        <p>destroyed（实例销毁之后）</p>

        <h3>14、vue生命周期的作用</h3>
        <p>给了用户在不同阶段添加自己的代码的机会</p>

        <h3>15、dom渲染在哪个生命周期阶段内完成？</h3>
        <p>dom渲染在mounted中就已经完成。</p>

        <h3>16、vue路由的实现？</h3>
        <p>前端路由就是更新视图，但是不请求页面，利用冇电完成企鹅号，页面不会刷新；</p>
        <p>官网推荐vue-router来引入路由模块。</p>

        <h3>17、简述vue路由模式hash和history</h3>
        <p>hash模式地址栏中有#号，history没有，history模式下刷新，会出现404，需要后台配置。</p>

        <h3>18、vue路由传参的两种方式，params和query方式与区别？</h3>
        <p>query用path引入，params用name引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name；</p>
        <p>url展示上：params类似于post，query类似于get，也就是安全问题；params传值相对更安全点，query通过url传参，刷新页面还在，params刷新页面不在了。</p>

        <h3>19、vue数据绑定的几种方式？</h3>
        <p>单向绑定：双大括号{{}}、html内字符串绑定</p>
        <p>v-bind绑定、html属性绑定</p>
        <p>双向绑定：v-model</p>
        <p>一次性绑定v-once，依赖于v-modal</p>

        <h3>20、vue如何注册一个全局组件？</h3>
        <p>Vue.componentVue.component('my-component-name', {// ... 选项 ...})</p>

        <h3>21、vue路由钩子/路由守卫有哪些？</h3>
        <p>全局守卫：beforeEach(to, from, next)和afterEach(to, from)</p>
        <p>组件内守卫：beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave</p>

        <h3>22、vue中如何进行动态路由设置？有哪些方式？怎么获取传递过来的数据？</h3>
        <p>动态路由也可以叫做路由传参，有query和params两种方式传参；</p>
        <p>query用path引入，params用name引入，query用this.$route.query.name接收参数，params用this.$route.params.name接收参数</p>

        <h3>23、Elementui中常用组件有哪些？</h3>
        <p>略。。。</p>

        <h3>24、vue如何自定义指令？</h3>
        <p>使用vue.directive('demo', function(el, binding){})</p>

        <h3>25、vue中指令有哪些？</h3>
        <p>v-for：循环数组、对象、字符串、数字；</p>
        <p>v-on：绑定事件监听；</p>
        <p>v-bind：动态绑定一个或多个属性</p>
        <p>v-model：表单空间或者组件上创建双向绑定</p>
        <p>v-if v-else v-else-if 条件渲染</p>
        <p>v-show 根据表达式真假，切换元素的display</p>
        <p>v-html 更新元素的textContent</p>
        <p>v-prev 跳过这个元素和子元素编译过程</p>
        <p>v-clock 这个指令保持在元素上知道关联实例结束编译</p>
        <p>v-once 只渲染一次</p>

        <h3>26、vue如何定义一个过滤器？</h3>
        <p>vue.filter('name', function(){})</p>

        <h3>27、对vue中keep-alive的理解？</h3>
        <p>概念：keep-alive是vue的内置组件，当它动态包裹组件时，会缓存不活动的组件实例，它自身不会渲染成一个dom元素也不会出现在父组件链中。</p>
        <p>作用：再组件企鹅号过程中将状态保留在内存中，防止重复渲染dom，减少加载事件以及性能消耗，提高用户体验</p>

        <h3>28、如何让组件中的css在当前组件生效？</h3>
        <p>在style中加上scoped；</p>

        <h3>29、vue生命周期一共有几个阶段？</h3>
        <p>创建、加载、更新、销毁</p>
        <p>beforeCreate 创建前</p>
        <p>created 创建后</p>
        <p>beforeMount 挂载前</p>
        <p>mounted 挂载后</p>
        <p>beforeUpdate 更新前</p>
        <p>updated 更新后</p>
        <p>beforeDestroy 销毁前</p>
        <p>destroyed 销毁后</p>

        <h3>30、mvvm和mvc的区别？</h3>
        <p>mvc：模型视图控制器，视图是可以直接访问模型，所以，视图里面会包含模型信息，mvc关注的时模型不变，所以，在mvc中，模型不依赖于视图，但是视图依赖模型。</p>
        <p>mvvm：模型+视图+vm，vm作为模型和视图的桥梁，当模型层数据改变，vm会检测道并通知视图层进行相应的修改。</p>

        <h3>31、vue组件中的data为什么是函数？</h3>
        <p>data是一个函数时，每个组件的实例都有自己的作用域，每个实例相互独立，不会影响。（或者说，保持数据的独立性，不被共享）</p>

        <h3>32、vue双向绑定的原理？</h3>
        <p>vue双向绑定就是：数据变化更新视图，视图变化更新数据。</p>
        <p>vue双向绑定是通过数据劫持和观察者模式来实现的。</p>
        <p>数据劫持：object.defineProperty，它的目的时：当给属性赋值的时候，程序可以感知到，就可以控制改变属性值；</p>
        <p>观察者模式：当属性发生改变的时候，使用该数据的地方也发生改变。</p>

        <h3>33、vue中组件怎么传值？</h3>
        <p>正向：父传子 父组件把要传递的数据绑定在属性上发送，子组件通过props接收；</p>
        <p>逆向：子传父 子组件通过this.$emit（自定义事件名，要发送的数据），父组件设置一个监听事件来接收，然后拿到数据；</p>
        <p>兄弟：eventBus 中央事件总线；</p>
        <p>通过vuex</p>

        <h3>34、Bootstrap的原理？</h3>
        <p>通过定义容器大小，平分12份，再调整内外边距，结合媒体查询，就成了强大的响应式网格系统。</p>

        <h3>37、请简述插槽？</h3>
        <p>略。。。</p>

        <h3>38、简述watch</h3>
        <p>watch的作用时监控一个值的变化，并调用因为变化需要执行的方法。</p>

        <h3>39、简述vant ui</h3>
        <p>轻量、可靠的移动端vue组件库</p>

        <h3>40、计算属性与watch区别？</h3>
        <p>computed watch 区别就是computed的缓存功能，当无关数据改变时，不会重新计算，直接使用缓存中的值。计算属性时用来声明式的描述一个值依赖了其他的值，当所以来的值后者变量发生变化时，计算属性也跟着改变。
        </p>
        <p>应用场景：</p>
        <p>computed：用于复杂的逻辑运算；一个数据受一个或多个数据影响；用来处理watch和methods无法处理的，或处理起来不方便的情况。例如处理模板中的复杂表达式、购物车里面的商品数量和总金额之间的变化关系等。
        </p>
        <p>watch：用来处理当一个属性发送变化时，需要执行某些具体的业务逻辑操作，或要在数量变化时执行异步或开销较大的操作；一个数据改变影响多个数据。例如用来监控路由、input输入框值的特殊处理等。</p>
        <p>参考：<a href="https://juejin.cn/post/6844903807592169486"
                target="_blank">https://juejin.cn/post/6844903807592169486</a></p>

        <h3>41、mvvm框架是什么？它和其他框架（jquery）的区别时什么？哪些场景合适？</h3>
        <p>mvvm和其他框架的区别是vue数据驱动，通过数据来显示视图而不是操作节点，适用于数据操作比较多的场景。</p>

        <h3>42、vue首屏加载慢的原因？怎么解决？白屏事件怎么检测？怎么解决白屏问题？</h3>
        <p>首屏加载慢的原因：第一次加载页面有很多组件数据需要渲染；</p>
        <p>解决方法：</p>
        <p>（1）路由懒加载 component: () => import('路由地址')</p>
        <p>（2）ui框架按需加载</p>
        <p>（3）gzip压缩</p>
        <p>白屏时间检测？</p>
        <p>参考1：<a href="https://juejin.cn/post/6844904185264095246"
                target="_blank">https://juejin.cn/post/6844904185264095246</a></p>
        <p>参考2：<a href="https://juejin.cn/post/6844904020482457613"
                target="_blank">https://juejin.cn/post/6844904020482457613</a></p>
        <p>解决白屏问题：</p>
        <p>（1）使用v-text渲染数据</p>
        <p>（2）使用{{}}预防渲染数据，但是同时是呀v-cloak指令（用来保持在元素上直到关联实例结束时进行编译）；v-cloack放置位置，并不需要添加到每个标签，只要在el挂载的标签上添加就可以。</p>

        <h3>43、vue双向数据绑定过程中，这边儿数据改变了怎么通知另一边改变？</h3>
        <p>数据劫持和观察者模式</p>
        <p>vue数据双向绑定是通过数据劫持和观察者模式来实现的</p>
        <p>数据劫持：object.defineProperty，它的目的是：当给属性赋值的时候，程序可以感知到，就可以控制属性值的有效范围，可以改变其他属性的值；</p>
        <p>观察者模式它的目的是当属性发生改变的时候，使用该数据的地方也发生改变。</p>

        <h3>44、vuex流程</h3>
        <p>在vue组件里面，通过dispatch来触发action提交修改数据的操作，然后通过actions的commit触发mutation来修改数据，mutations接收到commit的请求，就会自动通过mutate来修改state，最后触发每一个调用它的组件更新。
        </p>

        <h3>45、vuex怎么请求异步数据？</h3>
        <p>（1）首先在state中创建变量；</p>
        <p>（2）然后在action中调用封装好的axios请求，异步接收数据，commit提交给mutations；</p>
        <p>（3）mutations中改变state中的状态，将从action中获取到的值赋值给state。</p>

        <h3>46、vuex中action如何提交给mutation的？</h3>
        <p>action函数接受一个与store实例具有相同方法和属性的context对象，因此你可以调用context.commit提交一个mutation，或者通过context.state和context.getters来回去state和getters。
        </p>

        <h3>47、route和router的区别？</h3>
        <p>router是VueRouter的一个对象，通过vue.use(VueRouter)和VueRouter构造函数得到一个router实例对象，这个对象是一个全局的对象，它包含了所有的路由许多关键的对象和属性。</p>
        <p>route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name，path，params，query等。</p>
        <p>另一种回答：</p>
        <p> this.$route：当前激活的路由的信息对象。每个对象都是局部的，可以获取当前路由的 path, name, params, query 等属性。</p>
        <p>this.$router：全局的 router 实例。通过 vue 根实例中注入 router 实例，然后再注入到每个子组件，从而让整个应用都有路由功能。其中包含了很多属性和对象（比如 history
            对象），任何页面也都可以调用其 push(), replace(), go() 等方法</p>

        <h3>49、vuex的state特性是？</h3>
        <p>state是数据源的存放地；</p>
        <p>state里面的数据是响应式的，state中的数据改变，对应这个数据的组件也会发生改变；</p>
        <p>state通过mapstate把全局的state和getters映射到当前组件的计算属性中；</p>

        <h3>50、vuex的Getter特性是？</h3>
        <p>getter可以对state进行计算操作，它就是store的计算属性；</p>
        <p>getter可以在多组件之间敷用；</p>
        <p>如果一个状态只在一个组件内使用，可以不用getter；</p>

        <h3>51、vuex的mutation特性是？</h3>
        <p>更新vuex store中修改状态的唯一方法就是提交mutation，可以在回调函数中修改store中的状态；</p>

        <h3>52、vuex的action特性是？</h3>
        <p>action类似与mutation，不同的是action提交的是mutation，不是直接变更状态，可以包含任意异步操作；</p>

        <h3>54、vuex的优势？</h3>
        <p>优点：解决了非父子组件的通信，减少了ajax请求次数，有些可以直接从state中获取。</p>
        <p>缺点：刷新浏览器，vuex中的state会重新变为初始状态，解决办法是vuex-along，得配合计算属性和sessionStorage来实现。</p>

        <h3>55、vue路由懒加载（按需加载路由）</h3>
        <p>路由懒加载 component: () => import('路由地址')</p>

        <h3>56、v-for与v-if优先级？</h3>
        <p>不要v-for和v-if用在同一个元素上，原因：v-for比v-if优先级高；如歌每一次都需要遍历整个数组，将会影响速度，尤其是当需要渲染的只是很小一部分的时候；</p>

        <h3>57、请写出饿了么的5个组件</h3>
        <p>略。。。</p>

        <h3>58、vue在created和mounted这两个生命周期中请求数据有什么区别呢？</h3>
        <p>看实际情况，一般在created里面就可以，如果涉及到需要页面加载完成之后的话就用mounted。</p>
        <p>在create的时候，视图中的html并没有渲染处理，所以此时如果直接去操作html的dom节点，一定找不到相关元素。</p>
        <p>而mounted中，由于此时html依据渲染出来了，所以可以直接操作dom节点；</p>

        <h3>59、说说proxy的理解；</h3>
        <p>vue数据劫持的两个确定：</p>
        <p>（1）无法监听通过索引修改数组的值的变化；</p>
        <p>（2）无法监听object也就是对象的值的变化；所以vue2.x中才会有$set属性的存在；</p>
        <p>proxy是es6推出的新api，可以弥补以上两个缺点，所以vue3.x版本用proxy替换了object.defineProperty。</p>

        <h3>60、vue3是如何变得更快的？（底层、源码）</h3>
        <p>diff方法优化：</p>
        <p>vue2中的虚拟dom是进行全量的对比。</p>
        <p>vue3中新增了静态编辑：在与上次虚拟节点进行对比的时候，值对比带有patch flag的解ID那，并且可以通过flag的信息得知当前节点药对比的具体内容变化。</p>
        <p>vue2无论元素是否参与更新，都会重新创建。</p>
        <p>vue3对于不参与更新的元素，只会被创建一次，之后会每次渲染的时候被不停的复用；</p>
        <p>e.cachHandler事件侦听缓存；</p>
    </section>

    <section>
        <h2>React相关</h2>

        <h3>1、fetch vs ajax vs axios</h3>
        <p>传统ajax指的是XMLHttpRequest（XHR），最早出现是发送后请求技术，隶属于原始js，核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。jquery中ajax是对原生XHR的封装；
        </p>
        <p>axios是一个基于Promise，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范；</p>
        <p>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p>

        <h3>2、React事件处理-修改this指向？</h3>
        <p>（1）通过bind方法原地绑定，从而改变this指向</p>
        <p>（2）通过创建剪头函数</p>
        <p>（3）在constructor中提前对事件进行绑定</p>
        <p>（4）将事件调用的写法改为箭头函数的形式</p>

        <h3>3、简述对react的理解</h3>
        <p>React起源于facebook，它是一个用于用户界面的js库；</p>
        <p>特点：</p>
        <p>高效灵活：react使用VDOM，减少了与DOM的交互，而且它能与已知的库或框架完美配合。</p>
        <p>声明式的设计：react采用范式声明，开发者只需要声明显示内容，react就会自动完成。</p>
        <p>组件化：react的组件可以代码复用。</p>
        <p>单向数据流：react是单向数据流，数据通过props从父节点传递到子节点，如果父级的某个props改变了，react会重新渲染所有子节点。</p>
        <p>参考：<a href="https://www.w3cschool.cn/article/32850981.html"
                target="_blank">https://www.w3cschool.cn/article/32850981.html</a></p>

        <h3>4、react组件之间的数据传递</h3>
        <p>（1）父组件向子组件传递：props</p>
        <p>（2）子组件向父组件传递：通过事件调用函数传递</p>
        <p>（3）跨组件传递 用context</p>

        <h3>5、vue与react区别？</h3>
        <p>相同点：</p>
        <p>都有虚拟dom，组件化开发，通过props参数进行父子组件数据的传递；</p>
        <p>都实现web component规范；</p>
        <p>都是数据驱动视图；</p>
        <p>都有状态管理，react有redux，vue有vuex；</p>
        <p>都支持native的方案，react有react native；vue有weex；</p>

        <p>不同点：</p>
        <h4>答案一：</h4>
        <p>react严格上只针对mvc层的view层，vue是mvvm模式；</p>
        <p>虚拟dom不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个dom组件树，而react不同，当应用的状态改变时，全部组件都会重新渲染，所以react中用shouldComponentUpdate这个生命周期的钩子来控制；
        </p>
        <p>组件的写法不一样，react是jsx和inline stype，就是把html和css全部写进js中，vue则是html,css,js在同一个文件；</p>
        <p>数据绑定不一样，vue实现了双向绑定，react数据流动是单向的；在react中，state对象需要用setState方法更新状态，在vue中，state对象不是必须的，数据由data属性在vue对象中管理。</p>

        <h4>答案二：</h4>
        <p>（1）监听数据变化的原理不同</p>
        <p>vue通过getter/setter以及一些函数的劫持，能精确知道数据变化；</p>
        <p>react默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的VDOM的重新渲染。</p>
        <p>为什么react不精确监听数据变化呢？这是因为Vue和React设计理念上的区别，Vue使用的是可变数据，而React更加强调数据的不可变，两者没有好坏之分，Vue更加简单，而React构建大型应用时更加稳健。</p>
        <p>（2）数据流的不同</p>
        <p>vue支持双向绑定v-model，而react一直不支持，提倡单向数据流。</p>
        <p>（3）HOC和mixins</p>
        <p>（4）组件通信的区别</p>
        <p>（5）模板渲染方式的不同</p>
        <p>React通过JSX渲染模板，而Vue通过template渲染；</p>
        <p>（6）渲染过程不同</p>
        <p>（7）框架本质不同</p>
        <p>（8）Vuex和Redux的区别</p>
        <p>参考：<a href="https://zhuanlan.zhihu.com/p/100228073"
                target="_blank">https://zhuanlan.zhihu.com/p/100228073</a></p>

        <h3>6、请简述虚拟dom与diff算法</h3>
        <p>虚拟dom也就是常说的虚拟节点，它是通过js的object对象模拟dom中的节点，然后再通过特定的渲染方法将其渲染成真实的dom节点；频繁的操作dom，会大量造成页面的重绘和回流。</p>
        <p>diff算法：把树形结果按层级分解，只比较同级元素，给列表结果的每个单元添加唯一的key值，方便比较。</p>

        <h3>7、你对组件的理解</h3>
        <p>可组合，可服用，可维护，可测试；</p>

        <h3>8、调用setState之后发生了什么？</h3>
        <p>React在调用setState后，react会将传入的参数对象和组件当前的状态合并，触发调和过程，在调和过程中，react会根据新的状态构建react元素树重新渲染整个ui界面，在得到元素树之后，react会自动计算新老节点的差异，根据差异对界面进行最小化重新渲染。
        </p>

        <h3>9、react生命周期</h3>
        <p>componentWillMount 组件渲染之前调用</p>
        <p>componentDidMount 在第一次渲染之后调用</p>
        <p>componentWillReceiveProps 在组建接收到一个新的props时调用</p>
        <p>shouldComponentUpdate 判断组件是否更新html</p>
        <p>componentWillUpdate 组件即将更新html时调用</p>
        <p>componentDidUpdate 在组建完成更新后立即调用</p>
        <p>componentWillUnmount 在组建移除之前调用</p>

        <h3>10、为什么虚拟dom会提高性能？</h3>
        <p>虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。</p>

        <h3>11、组件的状态state和属性props之间有何不同？</h3>
        <p>props是一个从外部传进组件的参数，主要作用就是父组件向子组件传递数据，但是props对于使用它的组件来说是只读的，一旦赋值不能修改，只能通过外部组件主动传入新的props来重新渲染子组件。</p>
        <p>state
            一个组件的显示状态可以油数据状态和外部参数决定，用this.state给组件设定初始的state，在第一次渲染的时候就会用这个数据来渲染组件，state不同于props一点是，state可以修改，通过this.setState()方法来修改state。
        </p>

        <h3>12、shouldComponentUpdate是做什么的？</h3>
        <p>这个react生命钩子是用来解决下面的问题：</p>
        <p>在更新数据的时候state修改整个数据，数据变了之后，遍历的时候所有内容都要背重新渲染，数据量少还好，数据量大就会严重影响性能。</p>
        <p>（1）shouldComponentUpdate 在渲染前进行判断组件是否更新，更新了再渲染</p>
        <p>（2）pureComponent（纯组件）省去了虚拟dom生成和对比的过程，在类组件中使用</p>
        <p>（3）react.memo() 类似于纯组件 在无状态的组件中使用</p>

        <h3>13、react diff原理</h3>
        <p>tree diff web UI中的dom节点跨层级的移动操作特别少，可以忽略不急</p>
        <p>component diff 拥有相同类的两个组件将会生成相似的树形结果，拥有不同类的两个组件会生成不同的树形结构</p>
        <p>element diff对于同一层级的一组子节点，他们可以通过唯一的id进行区分</p>

        <h3>14、何为受控组件？</h3>
        <p>react负责渲染表单的组件，值是来自于state控制的，输入表单元素成为受控组件</p>

        <h3>15、调用super(props)的目的是什么？</h3>
        <p>super()调用父类的构造方法，有super，组件才有自己的this，在全局中都可以使用this，如果只是constructor而不执行super，之后的this都是错误的，super继承父组件的this</p>

        <h3>16、react中构建组件的方式</h3>
        <p>自定义组件：函数组件或者无状态组件 组件首字母大写</p>
        <p>类组件：一个类组件必须实现一个render方法，这个方法必须返回一个jsx元素，要用一个外层的元素把所有的内容包裹起来。</p>

        <h3>17、简述flux思想</h3>
        <p>flux最大的特点，就是数据的单向流动：</p>
        <p>（1）用户访问view，view发出用户的action；</p>
        <p>（2）dispatcher收到action，要求store进行相应更新；</p>
        <p>（3）更新后，发出一个change事件；</p>
        <p>（4）view收到change事件后，更新页面；</p>

        <h3>18、react项目用过什么脚手架？mern？yeoman？</h3>

        <h3>19、应该在React组件的何处发起Ajax请求？</h3>
        <p>componentDidMount中发起网络请求。</p>

        <h3>20、何为高阶组件？</h3>
        <p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC运行你重复的代码，逻辑和引导抽象。最常见的redux的connect函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享React组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的HOC。
        </p>
    </section>

    <section>
        <h2>其他</h2>

        <h3>1、Typescript是什么？请简述？</h3>
        <p>Tyescript是Javascript的超集。</p>
        <p>实现了静态类型、类、模块；可编译为Javascript，跨平台，支持所有浏览器、主机和操作系统。比Javascript更适合大型项目。</p>

        <h3>2、Typescript与Javascript的优势？</h3>
        <p>参考：<a href="https://juejin.cn/post/6844903545720815624"
                target="_blank">https://juejin.cn/post/6844903545720815624</a></p>

        <h3>3、webpack与gulp区别？</h3>
        <p>gulp是一种能够优化前端开发流程的工具，webpack是一种模块化的解决方案。</p>

        <h3>4、请简述webpack中的loaders与plugin的区别？</h3>
        <p>loader，它是一个转换器，将A文件进行编译城B文件，比如：将A.less转换城A.css，单纯的文件转换过程。</p>
        <p>plugin是一个扩展器，它丰富了webpack，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件的机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务。</p>
        <p>参考：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/308"
                target="_blank">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/308</a></p>

        <h3>5、怎么提升页面性能？性能优化有哪些？</h3>
        <p>加载优化：：：</p>
        <p>（1）减少http请求</p>
        <p>合并css和js，使用css雪碧图</p>
        <p>（2）缓存资源</p>
        <p>（3）压缩代码</p>
        <p>压缩代码，启用gzip</p>
        <p>（4）无阻塞</p>
        <p>样式放在头部并使用link方式引入，脚本放在尾部并使用一步方式加载</p>
        <p>（5）首屏加载</p>
        <p>（6）按需加载</p>
        <p>懒加载、滚屏加载</p>
        <p>（7）预加载</p>
        <p>（8）压缩图像</p>
        <p>（9）避免重定向</p>
        <p>（10）异步加载第三方资源</p>
        <p>执行优化：：：</p>
        <p>（1）css写在头部，js写在底部并且异步</p>
        <p>（2）避免img,iframe等src为空</p>
        <p>（3）尽量避免重置图像大小</p>
        <p>（4）图像尽量避免使用DataURL</p>
        <p>渲染优化：：：</p>
        <p>（1）设置viewport</p>
        <p>（2）减少dom操作</p>
        <p>（3）优化动画</p>
        <p>（4）优化高频事件</p>
        <p>（5）GPU加速</p>
        <p>样式优化：：：</p>
        <p>（1）避免在html中写style</p>
        <p>（2）避免css表达式</p>
        <p>（3）避免过长的选择器</p>
        <p>脚本优化：：：</p>
        <p>（1）减少重绘和回流</p>
        <p>（2）缓存DOM选择和计算</p>
        <p>（3）使用事件代理</p>

        <h3>6、Node是用来做什么的？</h3>
        <p>能够在服务器端运行的Javascript</p>

        <h3>7、说一下webpack的打包原理</h3>
        <p>webpack是把项目当作一个整体，通过给定一个主文件，webpack将从这个主文件开始找到项目中所有依赖的文件，使用loaders处理，最后打包城一个或者多个浏览器可识别的js文件。</p>
        <p>参考：<a href="https://juejin.cn/post/6844904038543130637" target="_blank">https://juejin.cn/post/6844904038543130637</a></p>

        <h3>8、commonjs ES6 模块区别？</h3>
        <p>commonjs模块是拷贝，可以修改值，ES6模块是引用，只读状态，不能修改值。</p>
        <p>commonjs模块是运行时加载，ES6模块是编译时输出接口。</p>

        <h3>9、Git如何使用/常用指令有哪些？</h3>
        <p>参考：<a href="https://www.yiibai.com/git/git_fetch.html"
                target="_blank">https://www.yiibai.com/git/git_fetch.html</a></p>

        <h3>10、你们后台用的是什么技术？</h3>
        <p>php</p>

        <h3>11、你的项目小为什么还是用vue全家桶？</h3>
        <p>略。。。</p>

        <h3>12、请简述你在项目中使用的ui框架？</h3>
        <p>略。。。</p>

        <h3>13、什么是cors？</h3>
        <p>略。。。</p>

        <h3>14、说一下对websocket的理解</h3>
        <p>websocket是一种双向通信协议，在建立连接后，websocket服务器和浏览器都能主动向对方发送和接收数据，websocket需要类似于TCP的客户端和服务器通过握手连接，连接成功后才能互相通信。</p>

        <h3>15、后台传递过来的数据是哪些？</h3>
        <p>略。。。</p>

        <h3>16、谈谈Ajax、fetch、axios的区别？</h3>
        <p>略。。。</p>
    </section>

    <section>
        <h2>企业中的项目流程</h2>
        <h3>1、web前端项目开发流程</h3>
        <p>（1）项目需要分析</p>
        <p>（2）页面设计</p>
        <p>（3）编码</p>
        <p>（4）测试</p>
        <p>（5）维护</p>

        <h3>2、大公司和小公司开发的区别？</h3>
        <p>大型公司更加流程化，人员多，沟通少，项目交付后不需要自己维护，采用瀑布开发模式；</p>
        <p>小型公司：人少，需求经常改变，沟通方便，采用敏捷开发；</p>


    </section>
    <script>
        // 22、请简述ajax的执行过程，以及常见的http状态码；
        // const xhr = new XMLHttpRequest();

        // xhr.open('GET', 'http://gameapi.37.com/index.php?c=h5-website&a=cont&game_id=708&format=jsonp&_=1608000674629&key=wap_top_img,wap_icon,wap_reserve_link,wap_download_qr,wap_download_android,wap_download_appstore,wap_kv,funny_img,wap_feature_img,footer_qr,gamesite_fcm_content_tips,gamesite_fcm_tips&callback=__jp4&_=1631007861862', true);

        // xhr.send();

        // xhr.onreadystatechange = function(){
        //     if(xhr.readyState == 4){
        //         if(xhr.status == 200){
        //             console.log(xhr.responseText);
        //         }
        //     }
        // }

        // 13、请写出一个简单的类与继承；
        // class Animal{
        //     constructor(name){
        //         this.name = name;
        //     }
        //     speak(){
        //         console.log(`${this.name} makes a noise`);
        //     }
        // }
        // class Dog extends Animal{
        //     constructor(name){
        //         super(name);
        //     }
        //     speak(){
        //         console.log(`${this.name} barks`);
        //     }
        // }

        // const d = new Dog('Mitzie');
        // d.speak();  //Mitzie barks

        // （1）原型链继承
        // function Parent(){
        //     this.name = 'Jenny';
        // }
        // Parent.prototype.getName = function(){
        //     console.log(this.name);
        // }

        // function Child(){}
        // Child.prototype = new Parent();

        // var child1 = new Child();
        // child1.getName();   //Jenny

        // 问题一：引用类型的所有属性被实例共享；
        // function Parent(){
        //     this.names = ['Jenny', 'Gily'];
        // }

        // function Child(){}
        // Child.prototype = new Parent();

        // var child1 = new Child();
        // child1.names.push('gaga');
        // console.log(child1.names);  //["Jenny", "Gily", "gaga"]

        // var child2 = new Child();
        // console.log(child2.names);  //["Jenny", "Gily", "gaga"]

        // 问题二：在创建Child的实例时，不能向Parent传参

        // （2）借用构造函数（经典继承）
        // function Parent(){
        //     this.names = ['Jenny', 'Gily'];
        // }

        // function Child(){
        //     Parent.call(this);
        // }

        // var child1 = new Child();
        // child1.names.push('gaga');
        // console.log(child1.names);  //["Jenny", "Gily", "gaga"]

        // var child2 = new Child();
        // console.log(child2.names);  //["Jenny", "Gily"]

        // 优点：
        // <1>避免了引用类型的属性被所有实例共享
        // <2>可以在Child中向Parent传递参数
        // function Parent(name){
        //     this.name = name;
        // }

        // function Child(name){
        //     Parent.call(this, name);
        // }

        // var child1 = new Child('Jenny');
        // console.log(child1.name);  //Jenny

        // var child2 = new Child('Gily');
        // console.log(child2.name);  //Gily

        // 缺点：
        // 方法都在构造函数中定义，每次创建实例都会创建一遍方法。

        // （3）组合继承
        // 原型链继承和借用构造函数法的结合
        // function Parent(name){
        //     this.name = name;
        //     this.colors = ['red', 'blue', 'green'];
        // }
        // Parent.prototype.getName = function(){
        //     console.log(this.name);
        // }

        // function Child(name, age){
        //     Parent.call(this, name);
        //     this.age = age;
        // }
        // Child.prototype = new Parent();

        // var child1 = new Child('Jenny', 18);
        // child1.colors.push('black');
        // console.log(child1.name);   //Jenny
        // console.log(child1.age);    //18
        // console.log(child1.colors); //["red", "blue", "green", "black"]

        // var child2 = new Child('Gily', 20);
        // console.log(child2.name);   //Gily
        // console.log(child2.age);    //20
        // console.log(child2.colors); //["red", "blue", "green"]
        // 优点：融合原型链继承和构造函数的优点，是js中最常用的继承方式

        // （4）原型式继承
        // function createObj(o){
        //     function F(){}
        //     F.prototype = o;
        //     return new F();
        // }

        // var person = {
        //     name: 'Jenny',
        //     friends: ['Gily', 'Mike']
        // };

        // var person1 = createObj(person);
        // var person2 = createObj(person);

        // person1.name = 'person1';
        // console.log(person2.name);  //Jenny

        // person1.friends.push('Taylor');
        // console.log(person2.friends);   //["Gily", "Mike", "Taylor"]
        // 缺点：
        // 包含引用类型的属性值始终都会共享相应的值，这点跟原型继承一样

        // （5）寄生式继承
        // function createObj(o){
        //     var clone = Object.create(o);
        //     clone.sayName = function(){
        //         console.log('hi');
        //     }
        //     return clone;
        // }
        // 缺点：
        // 跟借用构造函数模式一样，每次创建对象会创建一遍方法

        // （6）寄生组合式继承
        // 组合继承最大缺点是会调用两次父构造函数
        // 一次是设置子类实例原型的时候：
        // Child.prototype = new Parent();
        // 一次在创建子类实例的时候：
        // var child1 = new Child('Jenny', 18);

        // 如果我们不使用Child.prototype = new Parent()，而是间接的让Child.prototype访问到Parent.prototype呢？
        // function Parent(name){
        //     this.name = name;
        //     this.colors = ['red', 'blue', 'green'];
        // }
        // Parent.prototype.getName = function(){
        //     console.log(this.name);
        // }

        // function Child(name, age){
        //     Parent.call(this, name);
        //     this.age = age;
        // }

        // // 关键的三步
        // var F = function(){}
        // F.prototype = Parent.prototype;
        // Child.prototype = new F();

        // var child1 = new Child('Jenny', 18);
        // console.log(child1);
        // 优点：只调用了一次Parent构造函数，并且避免了在Parent.prototype上创建不必要的、多余的属性。与此同时，原型链还能保持不变。


        // 28、js的各种位置
        // var div = document.getElementById('allHeight');
        // （1）clientHeight：表示可视区的高度，不包含border和滚动条
        // console.log(document.documentElement.clientHeight);
        // （2）offsetHeight：表示可视区的高度，包含border和滚动条
        // console.log(document.documentElement.offsetHeight);     //14121
        // （3）scrollHeight：元素内容的高度，其中包含由于溢出而在屏幕上不可见的内容。
        // console.log(document.documentElement.scrollHeight);     //14121
        // （4）scrollTop：有滚动条时，滚动条向下滚动的距离，也就是被元素顶部遮住的部分的高度。没有滚动条时等于0；
        // console.log(document.documentElement.scrollTop);
        // （5）offsetTop：返回当前元素相对与最近的offsetParent父节点顶部的距离。和滚动条没有关系。
        // console.log(document.documentElement.clientTop);

        // console.log(div.offsetHeight);  //320
        // console.log(document.documentElement.offsetHeight); //16474
        // document.addEventListener('scroll', function(){
        //     console.log(document.documentElement.scrollTop);
        //     // if(document.documentElement.scrollTop > document.documentElement.offsetHeight - div.offsetTop){
        //     //     console.log('滚动到div了');
        //     // };
        // }, false)


        // 16、请简述原型、原型链、继承
        // function Person(nick, age){
        //     this.nick = nick;
        //     this.age = age;
        // }
        // Person.prototype.sayName = function(){
        //     console.log(this.nick);
        // }
        // var p1 = new Person('zhangsan', 20);
        // var p2 = new Person('lisi', 18);
        // p1.sayName();   //zhangsan
        // p2.sayName();   //lisi
        // console.log(p1.__proto__ === Person.prototype); //true
        // console.log(p2.__proto__ === Person.prototype); //true
        // console.log(p1.__proto__ === p2.__proto__);     //true
        // console.log(Person.prototype.constructor === Person);   //true

        // 12、数组方法有哪些？请简述
        // const arr = [2,3];
        // console.log(arr.push(4));   //3

        // const arr = [1,2,3,4];
        // console.log(arr.pop());

        // const arr = [1,2,3,4];
        // console.log(arr.shift());   //1

        // const arr = [2,3,4];
        // console.log(arr.unshift(1));

        // const arr = [1,2,3,4,5];
        // console.log(arr.splice(2, 2));  //[3, 4]

        // const arr1 = [1,2];
        // const arr2 = [4,5,6];
        // console.log(arr1.concat(arr2)); //[1, 2, 4, 5, 6]

        // const arr = [5, 18, 2, 36];
        // console.log(arr.sort());    //[18, 2, 36, 5]

        // const arr = [1, 2, 3, 4];
        // console.log(arr.reverse()); //[4, 3, 2, 1]

        // const arr = [1, 2, 3, 4];
        // console.log(arr.slice(1,3));    //[2, 3]

        // const arr = [1, 2, 3, 4];
        // console.log( arr.forEach((index, item) => {
        //     return 1;
        // }));
        // 无返回值

        // const arr = [1, 2, 3, 4];
        // console.log( arr.map((item, index) => {
        //     return item * 2;
        // }));

        // const arr = [1, 2, 3, 4];
        // console.log(arr.filter((item, index) => {
        //     return item % 2 == 0;
        // }))

        // 11、let和var以及const区别？
        // （1）js无块级作用域
        // for(var i=0;i<10;i++){
        //     var a = 'a';
        // }
        // console.log(a); //a

        // （2）循环变量过度共享
        // for(var i = 0;i < 3;i++){
        //     setTimeout(function(){
        //         console.log(i);
        //     }, 1000)
        // }
        // 打印3个3

        // let a = 'a';
        // let a = 'b';
        // Uncaught SyntaxError: Identifier 'a' has already been declared

        // const a;

        // const a = 'a';
        // const a = 'b';

        // const a = 'a';
        // a = 'b';

        // const a = {a: 'a'};
        // a = {a: 'b'};
        // a.a = 'b';

        // 3、如何判断一个数据是NaN？
        // console.log(typeof NaN);    //number

        // （1）利用NaN是唯一一个不等于自身的特点；
        // function isNaN(val){
        //     if(val !== val){
        //         return true;
        //     }
        //     return false;
        // }

        // console.log(isNaN('as'));

        // （2）利用ES6中提供的Object.is()方法；
        // const a = 'string';
        // const b = 2;
        // const c = a/b;

        // console.log(Object.is(a, NaN));     //false
        // console.log(Object.is(b, NaN));     //false
        // console.log(Object.is(c, NaN));     //true

        // （3）使用isNaN（不推荐）
        // function _isNaN(val){
        //     if(typeof(val === 'number' && isNaN(val))){
        //         return true;
        //     }
        //     return false;
        // }
        // console.log(_isNaN(1));
        // 参考：https://blog.csdn.net/AiHuanhuan110/article/details/109448153

        // const xhr = new XMLHttpRequest();
        // xhr.open('GET', 'http://gameapi.37.com/index.php?c=h5-website&a=cont&game_id=708&format=jsonp&_=1608000674629&key=wap_top_img,wap_icon,wap_reserve_link,wap_download_qr,wap_download_android,wap_download_appstore,wap_kv,funny_img,wap_feature_img,footer_qr,gamesite_fcm_content_tips,gamesite_fcm_tips&callback=__jp4&_=1630397541455', true);
        // xhr.send();
        // xhr.onreadystatechange = function(){
        //     if(xhr.readyState == 4 && xhr.status == 200){
        //         console.log(xhr.responseText);
        //     }
        // }
    </script>
</body>

</html>